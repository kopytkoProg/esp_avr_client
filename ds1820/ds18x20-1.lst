   1               		.file	"ds18x20-1.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	DS18X20_raw_to_decicelsius:
  12               	.LFB6:
  13               		.file 1 "ds1820/ds18x20-1.c"
   1:ds1820/ds18x20-1.c **** /*********************************************************************************
   2:ds1820/ds18x20-1.c ****  Title:    DS18X20-Functions via One-Wire-Bus
   3:ds1820/ds18x20-1.c ****  Author:   Martin Thomas <eversmith@heizung-thomas.de>
   4:ds1820/ds18x20-1.c ****  http://www.siwawi.arubi.uni-kl.de/avr-projects
   5:ds1820/ds18x20-1.c ****  Software: avr-gcc 4.3.3 / avr-libc 1.6.7 (WinAVR 3/2010)
   6:ds1820/ds18x20-1.c ****  Hardware: any AVR - tested with ATmega16/ATmega32/ATmega324P and 3 DS18B20
   7:ds1820/ds18x20-1.c **** 
   8:ds1820/ds18x20-1.c ****  Partly based on code from Peter Dannegger and others.
   9:ds1820/ds18x20-1.c **** 
  10:ds1820/ds18x20-1.c ****  changelog:
  11:ds1820/ds18x20-1.c ****  20041124 - Extended measurements for DS18(S)20 contributed by Carsten Foss (CFO)
  12:ds1820/ds18x20-1.c ****  200502xx - function DS18X20_read_meas_single
  13:ds1820/ds18x20-1.c ****  20050310 - DS18x20 EEPROM functions (can be disabled to save flash-memory)
  14:ds1820/ds18x20-1.c ****  (DS18X20_EEPROMSUPPORT in ds18x20.h)
  15:ds1820/ds18x20-1.c ****  20100625 - removed inner returns, added static function for read scratchpad
  16:ds1820/ds18x20-1.c ****  . replaced full-celcius and fractbit method with decicelsius
  17:ds1820/ds18x20-1.c ****  and maxres (degreeCelsius*10e-4) functions, renamed eeprom-functions,
  18:ds1820/ds18x20-1.c ****  delay in recall_e2 replaced by timeout-handling
  19:ds1820/ds18x20-1.c ****  20100714 - ow_command_skip_last_recovery used for parasite-powerd devices so the
  20:ds1820/ds18x20-1.c ****  strong pull-up can be enabled in time even with longer OW recovery times
  21:ds1820/ds18x20-1.c ****  20110209 - fix in DS18X20_format_from_maxres() by Marian Kulesza
  22:ds1820/ds18x20-1.c ****  **********************************************************************************/
  23:ds1820/ds18x20-1.c **** 
  24:ds1820/ds18x20-1.c **** #include <stdlib.h>
  25:ds1820/ds18x20-1.c **** #include <stdint.h>
  26:ds1820/ds18x20-1.c **** 
  27:ds1820/ds18x20-1.c **** #include <avr/io.h>
  28:ds1820/ds18x20-1.c **** #include <avr/pgmspace.h>
  29:ds1820/ds18x20-1.c **** 
  30:ds1820/ds18x20-1.c **** #include "ds18x20.h"
  31:ds1820/ds18x20-1.c **** #include "onewire.h"
  32:ds1820/ds18x20-1.c **** #include "crc8.h"
  33:ds1820/ds18x20-1.c **** 
  34:ds1820/ds18x20-1.c **** #if DS18X20_EEPROMSUPPORT
  35:ds1820/ds18x20-1.c **** // for 10ms delay in copy scratchpad
  36:ds1820/ds18x20-1.c **** #include <util/delay.h>
  37:ds1820/ds18x20-1.c **** #endif /* DS18X20_EEPROMSUPPORT */
  38:ds1820/ds18x20-1.c **** 
  39:ds1820/ds18x20-1.c **** /*----------- start of "debug-functions" ---------------*/
  40:ds1820/ds18x20-1.c **** 
  41:ds1820/ds18x20-1.c **** #if DS18X20_VERBOSE
  42:ds1820/ds18x20-1.c **** #if (!DS18X20_DECICELSIUS)
  43:ds1820/ds18x20-1.c **** #error "DS18X20_DECICELSIUS must be enabled for verbose-mode"
  44:ds1820/ds18x20-1.c **** #endif
  45:ds1820/ds18x20-1.c **** 
  46:ds1820/ds18x20-1.c **** /* functions for debugging-output - undef DS18X20_VERBOSE in .h
  47:ds1820/ds18x20-1.c ****  if you run out of program-memory */
  48:ds1820/ds18x20-1.c **** #include <string.h>
  49:ds1820/ds18x20-1.c **** #include "uart.h"
  50:ds1820/ds18x20-1.c **** #include "uart_addon.h"
  51:ds1820/ds18x20-1.c **** 
  52:ds1820/ds18x20-1.c **** static int16_t DS18X20_raw_to_decicelsius( uint8_t fc, uint8_t sp[] );
  53:ds1820/ds18x20-1.c **** 
  54:ds1820/ds18x20-1.c **** void DS18X20_show_id_uart( uint8_t *id, size_t n )
  55:ds1820/ds18x20-1.c **** {
  56:ds1820/ds18x20-1.c **** 	size_t i;
  57:ds1820/ds18x20-1.c **** 
  58:ds1820/ds18x20-1.c **** 	for( i = 0; i < n; i++ ) {
  59:ds1820/ds18x20-1.c **** 		if ( i == 0 ) {uart_puts_P( "FC:" );}
  60:ds1820/ds18x20-1.c **** 		else if ( i == n-1 ) {uart_puts_P( "CRC:" );}
  61:ds1820/ds18x20-1.c **** 		if ( i == 1 ) {uart_puts_P( "SN: " );}
  62:ds1820/ds18x20-1.c **** 		uart_puthex_byte(id[i]);
  63:ds1820/ds18x20-1.c **** 		uart_puts_P(" ");
  64:ds1820/ds18x20-1.c **** 		if ( i == 0 ) {
  65:ds1820/ds18x20-1.c **** 			if ( id[0] == DS18S20_FAMILY_CODE ) {uart_puts_P ("(18S)");}
  66:ds1820/ds18x20-1.c **** 			else if ( id[0] == DS18B20_FAMILY_CODE ) {uart_puts_P ("(18B)");}
  67:ds1820/ds18x20-1.c **** 			else if ( id[0] == DS1822_FAMILY_CODE ) {uart_puts_P ("(22)");}
  68:ds1820/ds18x20-1.c **** 			else {uart_puts_P ("( ? )");}
  69:ds1820/ds18x20-1.c **** 		}
  70:ds1820/ds18x20-1.c **** 	}
  71:ds1820/ds18x20-1.c **** 	if ( crc8( id, OW_ROMCODE_SIZE) )
  72:ds1820/ds18x20-1.c **** 	uart_puts_P( " CRC FAIL " );
  73:ds1820/ds18x20-1.c **** 	else
  74:ds1820/ds18x20-1.c **** 	uart_puts_P( " CRC O.K. " );
  75:ds1820/ds18x20-1.c **** }
  76:ds1820/ds18x20-1.c **** 
  77:ds1820/ds18x20-1.c **** static void show_sp_uart( uint8_t *sp, size_t n )
  78:ds1820/ds18x20-1.c **** {
  79:ds1820/ds18x20-1.c **** 	size_t i;
  80:ds1820/ds18x20-1.c **** 
  81:ds1820/ds18x20-1.c **** 	uart_puts_P( "SP:" );
  82:ds1820/ds18x20-1.c **** 	for( i = 0; i < n; i++ ) {
  83:ds1820/ds18x20-1.c **** 		if ( i == n-1 ) {uart_puts_P( "CRC:" );}
  84:ds1820/ds18x20-1.c **** 		uart_puthex_byte(sp[i]);
  85:ds1820/ds18x20-1.c **** 		uart_puts_P(" ");
  86:ds1820/ds18x20-1.c **** 	}
  87:ds1820/ds18x20-1.c **** }
  88:ds1820/ds18x20-1.c **** 
  89:ds1820/ds18x20-1.c **** /*
  90:ds1820/ds18x20-1.c ****  convert raw value from DS18x20 to Celsius
  91:ds1820/ds18x20-1.c ****  input is:
  92:ds1820/ds18x20-1.c ****  - familycode fc (0x10/0x28 see header)
  93:ds1820/ds18x20-1.c ****  - scratchpad-buffer
  94:ds1820/ds18x20-1.c ****  output is:
  95:ds1820/ds18x20-1.c ****  - cel full celsius
  96:ds1820/ds18x20-1.c ****  - fractions of celsius in millicelsius*(10^-1)/625 (the 4 LS-Bits)
  97:ds1820/ds18x20-1.c ****  - subzero =0 positiv / 1 negativ
  98:ds1820/ds18x20-1.c ****  always returns  DS18X20_OK
  99:ds1820/ds18x20-1.c ****  */
 100:ds1820/ds18x20-1.c **** static uint8_t DS18X20_meas_to_cel( uint8_t fc, uint8_t *sp,
 101:ds1820/ds18x20-1.c **** 		uint8_t* subzero, uint8_t* cel, uint8_t* cel_frac_bits)
 102:ds1820/ds18x20-1.c **** {
 103:ds1820/ds18x20-1.c **** 	uint16_t meas;
 104:ds1820/ds18x20-1.c **** 	uint8_t i;
 105:ds1820/ds18x20-1.c **** 
 106:ds1820/ds18x20-1.c **** 	meas = sp[0];  // LSB
 107:ds1820/ds18x20-1.c **** 	meas |= ( (uint16_t)sp[1] ) << 8;// MSB
 108:ds1820/ds18x20-1.c **** 
 109:ds1820/ds18x20-1.c **** 	//  only work on 12bit-base
 110:ds1820/ds18x20-1.c **** 	if( fc == DS18S20_FAMILY_CODE ) { // 9 -> 12 bit if 18S20
 111:ds1820/ds18x20-1.c **** 		/* Extended res. measurements for DS18S20 contributed by Carsten Foss */
 112:ds1820/ds18x20-1.c **** 		meas &= (uint16_t) 0xfffe;    // Discard LSB, needed for later extended precicion calc
 113:ds1820/ds18x20-1.c **** 		meas <<= 3;// Convert to 12-bit, now degrees are in 1/16 degrees units
 114:ds1820/ds18x20-1.c **** 		meas += ( 16 - sp[6] ) - 4;// Add the compensation and remember to subtract 0.25 degree (4/16)
 115:ds1820/ds18x20-1.c **** 	}
 116:ds1820/ds18x20-1.c **** 
 117:ds1820/ds18x20-1.c **** 	// check for negative
 118:ds1820/ds18x20-1.c **** 	if ( meas & 0x8000 ) {
 119:ds1820/ds18x20-1.c **** 		*subzero=1;      // mark negative
 120:ds1820/ds18x20-1.c **** 		meas ^= 0xffff;// convert to positive => (twos complement)++
 121:ds1820/ds18x20-1.c **** 		meas++;
 122:ds1820/ds18x20-1.c **** 	}
 123:ds1820/ds18x20-1.c **** 	else {
 124:ds1820/ds18x20-1.c **** 		*subzero=0;
 125:ds1820/ds18x20-1.c **** 	}
 126:ds1820/ds18x20-1.c **** 
 127:ds1820/ds18x20-1.c **** 	// clear undefined bits for B != 12bit
 128:ds1820/ds18x20-1.c **** 	if ( fc == DS18B20_FAMILY_CODE || fc == DS1822_FAMILY_CODE ) {
 129:ds1820/ds18x20-1.c **** 		i = sp[DS18B20_CONF_REG];
 130:ds1820/ds18x20-1.c **** 		if ( (i & DS18B20_12_BIT) == DS18B20_12_BIT ) {;}
 131:ds1820/ds18x20-1.c **** 		else if ( (i & DS18B20_11_BIT) == DS18B20_11_BIT ) {
 132:ds1820/ds18x20-1.c **** 			meas &= ~(DS18B20_11_BIT_UNDF);
 133:ds1820/ds18x20-1.c **** 		} else if ( (i & DS18B20_10_BIT) == DS18B20_10_BIT ) {
 134:ds1820/ds18x20-1.c **** 			meas &= ~(DS18B20_10_BIT_UNDF);
 135:ds1820/ds18x20-1.c **** 		} else { // if ( (i & DS18B20_9_BIT) == DS18B20_9_BIT ) {
 136:ds1820/ds18x20-1.c **** 			meas &= ~(DS18B20_9_BIT_UNDF);
 137:ds1820/ds18x20-1.c **** 		}
 138:ds1820/ds18x20-1.c **** 	}
 139:ds1820/ds18x20-1.c **** 
 140:ds1820/ds18x20-1.c **** 	*cel = (uint8_t)(meas >> 4);
 141:ds1820/ds18x20-1.c **** 	*cel_frac_bits = (uint8_t)(meas & 0x000F);
 142:ds1820/ds18x20-1.c **** 
 143:ds1820/ds18x20-1.c **** 	return DS18X20_OK;
 144:ds1820/ds18x20-1.c **** }
 145:ds1820/ds18x20-1.c **** 
 146:ds1820/ds18x20-1.c **** static void DS18X20_uart_put_temp(const uint8_t subzero,
 147:ds1820/ds18x20-1.c **** 		const uint8_t cel, const uint8_t cel_frac_bits)
 148:ds1820/ds18x20-1.c **** {
 149:ds1820/ds18x20-1.c **** 	char buffer[sizeof(int)*8+1];
 150:ds1820/ds18x20-1.c **** 	size_t i;
 151:ds1820/ds18x20-1.c **** 
 152:ds1820/ds18x20-1.c **** 	uart_putc((subzero)?'-':'+');
 153:ds1820/ds18x20-1.c **** 	uart_put_int((int)cel);
 154:ds1820/ds18x20-1.c **** 	uart_puts_P(".");
 155:ds1820/ds18x20-1.c **** 	itoa(cel_frac_bits*DS18X20_FRACCONV,buffer,10);
 156:ds1820/ds18x20-1.c **** 	for ( i = 0; i < 4-strlen(buffer); i++ ) {
 157:ds1820/ds18x20-1.c **** 		uart_puts_P("0");
 158:ds1820/ds18x20-1.c **** 	}
 159:ds1820/ds18x20-1.c **** 	uart_puts(buffer);
 160:ds1820/ds18x20-1.c **** 	uart_puts_P("�C");
 161:ds1820/ds18x20-1.c **** }
 162:ds1820/ds18x20-1.c **** 
 163:ds1820/ds18x20-1.c **** /* verbose output rom-search follows read-scratchpad in one loop */
 164:ds1820/ds18x20-1.c **** uint8_t DS18X20_read_meas_all_verbose( void )
 165:ds1820/ds18x20-1.c **** {
 166:ds1820/ds18x20-1.c **** 	uint8_t id[OW_ROMCODE_SIZE], sp[DS18X20_SP_SIZE], diff;
 167:ds1820/ds18x20-1.c **** 	uint8_t i;
 168:ds1820/ds18x20-1.c **** 	uint16_t meas;
 169:ds1820/ds18x20-1.c **** 	int16_t decicelsius;
 170:ds1820/ds18x20-1.c **** 	char s[10];
 171:ds1820/ds18x20-1.c **** 	uint8_t subzero, cel, cel_frac_bits;
 172:ds1820/ds18x20-1.c **** 
 173:ds1820/ds18x20-1.c **** 	for( diff = OW_SEARCH_FIRST; diff != OW_LAST_DEVICE; )
 174:ds1820/ds18x20-1.c **** 	{
 175:ds1820/ds18x20-1.c **** 		diff = ow_rom_search( diff, &id[0] );
 176:ds1820/ds18x20-1.c **** 
 177:ds1820/ds18x20-1.c **** 		if( diff == OW_PRESENCE_ERR ) {
 178:ds1820/ds18x20-1.c **** 			uart_puts_P( "No Sensor found\r" );
 179:ds1820/ds18x20-1.c **** 			return OW_PRESENCE_ERR; // <--- early exit!
 180:ds1820/ds18x20-1.c **** 		}
 181:ds1820/ds18x20-1.c **** 
 182:ds1820/ds18x20-1.c **** 		if( diff == OW_DATA_ERR ) {
 183:ds1820/ds18x20-1.c **** 			uart_puts_P( "Bus Error\r" );
 184:ds1820/ds18x20-1.c **** 			return OW_DATA_ERR;     // <--- early exit!
 185:ds1820/ds18x20-1.c **** 		}
 186:ds1820/ds18x20-1.c **** 
 187:ds1820/ds18x20-1.c **** 		DS18X20_show_id_uart( id, OW_ROMCODE_SIZE );
 188:ds1820/ds18x20-1.c **** 
 189:ds1820/ds18x20-1.c **** 		if( id[0] == DS18B20_FAMILY_CODE || id[0] == DS18S20_FAMILY_CODE ||
 190:ds1820/ds18x20-1.c **** 				id[0] == DS1822_FAMILY_CODE ) {
 191:ds1820/ds18x20-1.c **** 			// temperature sensor
 192:ds1820/ds18x20-1.c **** 
 193:ds1820/ds18x20-1.c **** 			uart_putc ('\r');
 194:ds1820/ds18x20-1.c **** 
 195:ds1820/ds18x20-1.c **** 			ow_byte_wr( DS18X20_READ );// read command
 196:ds1820/ds18x20-1.c **** 
 197:ds1820/ds18x20-1.c **** 			for ( i=0; i< DS18X20_SP_SIZE; i++ ) {
 198:ds1820/ds18x20-1.c **** 				sp[i]=ow_byte_rd();
 199:ds1820/ds18x20-1.c **** 			}
 200:ds1820/ds18x20-1.c **** 
 201:ds1820/ds18x20-1.c **** 			show_sp_uart( sp, DS18X20_SP_SIZE );
 202:ds1820/ds18x20-1.c **** 
 203:ds1820/ds18x20-1.c **** 			if ( crc8( &sp[0], DS18X20_SP_SIZE ) ) {
 204:ds1820/ds18x20-1.c **** 				uart_puts_P( " CRC FAIL " );
 205:ds1820/ds18x20-1.c **** 			} else {
 206:ds1820/ds18x20-1.c **** 				uart_puts_P( " CRC O.K. " );
 207:ds1820/ds18x20-1.c **** 			}
 208:ds1820/ds18x20-1.c **** 			uart_putc ('\r');
 209:ds1820/ds18x20-1.c **** 
 210:ds1820/ds18x20-1.c **** 			meas = sp[0]; // LSB Temp. from Scrachpad-Data
 211:ds1820/ds18x20-1.c **** 			meas |= (uint16_t) (sp[1] << 8);// MSB
 212:ds1820/ds18x20-1.c **** 
 213:ds1820/ds18x20-1.c **** 			uart_puts_P( " T_raw=");
 214:ds1820/ds18x20-1.c **** 			uart_puthex_byte( (uint8_t)(meas >> 8) );
 215:ds1820/ds18x20-1.c **** 			uart_puthex_byte( (uint8_t)meas );
 216:ds1820/ds18x20-1.c **** 			uart_puts_P( " " );
 217:ds1820/ds18x20-1.c **** 
 218:ds1820/ds18x20-1.c **** 			if( id[0] == DS18S20_FAMILY_CODE ) { // 18S20
 219:ds1820/ds18x20-1.c **** 				uart_puts_P( "S20/09" );
 220:ds1820/ds18x20-1.c **** 			}
 221:ds1820/ds18x20-1.c **** 			else if ( id[0] == DS18B20_FAMILY_CODE ||
 222:ds1820/ds18x20-1.c **** 					id[0] == DS1822_FAMILY_CODE ) { // 18B20 or 1822
 223:ds1820/ds18x20-1.c **** 				i=sp[DS18B20_CONF_REG];
 224:ds1820/ds18x20-1.c **** 				if ( (i & DS18B20_12_BIT) == DS18B20_12_BIT ) {
 225:ds1820/ds18x20-1.c **** 					uart_puts_P( "B20/12" );
 226:ds1820/ds18x20-1.c **** 				}
 227:ds1820/ds18x20-1.c **** 				else if ( (i & DS18B20_11_BIT) == DS18B20_11_BIT ) {
 228:ds1820/ds18x20-1.c **** 					uart_puts_P( "B20/11" );
 229:ds1820/ds18x20-1.c **** 				}
 230:ds1820/ds18x20-1.c **** 				else if ( (i & DS18B20_10_BIT) == DS18B20_10_BIT ) {
 231:ds1820/ds18x20-1.c **** 					uart_puts_P( " B20/10 " );
 232:ds1820/ds18x20-1.c **** 				}
 233:ds1820/ds18x20-1.c **** 				else { // if ( (i & DS18B20_9_BIT) == DS18B20_9_BIT ) {
 234:ds1820/ds18x20-1.c **** 					uart_puts_P( "B20/09" );
 235:ds1820/ds18x20-1.c **** 				}
 236:ds1820/ds18x20-1.c **** 			}
 237:ds1820/ds18x20-1.c **** 			uart_puts_P(" ");
 238:ds1820/ds18x20-1.c **** 
 239:ds1820/ds18x20-1.c **** 			DS18X20_meas_to_cel( id[0], sp, &subzero, &cel, &cel_frac_bits );
 240:ds1820/ds18x20-1.c **** 			DS18X20_uart_put_temp( subzero, cel, cel_frac_bits );
 241:ds1820/ds18x20-1.c **** 
 242:ds1820/ds18x20-1.c **** 			decicelsius = DS18X20_raw_to_decicelsius( id[0], sp );
 243:ds1820/ds18x20-1.c **** 			if ( decicelsius == DS18X20_INVALID_DECICELSIUS ) {
 244:ds1820/ds18x20-1.c **** 				uart_puts_P("* INVALID *");
 245:ds1820/ds18x20-1.c **** 			} else {
 246:ds1820/ds18x20-1.c **** 				uart_puts_P(" conv: ");
 247:ds1820/ds18x20-1.c **** 				uart_put_int(decicelsius);
 248:ds1820/ds18x20-1.c **** 				uart_puts_P(" deci�C ");
 249:ds1820/ds18x20-1.c **** 				DS18X20_format_from_decicelsius( decicelsius, s, 10 );
 250:ds1820/ds18x20-1.c **** 				uart_puts_P(" fmt: ");
 251:ds1820/ds18x20-1.c **** 				uart_puts(s);
 252:ds1820/ds18x20-1.c **** 				uart_puts_P(" �C ");
 253:ds1820/ds18x20-1.c **** 			}
 254:ds1820/ds18x20-1.c **** 
 255:ds1820/ds18x20-1.c **** 			uart_puts("\r");
 256:ds1820/ds18x20-1.c **** 
 257:ds1820/ds18x20-1.c **** 		} // if meas-sensor
 258:ds1820/ds18x20-1.c **** 
 259:ds1820/ds18x20-1.c **** 	} // loop all sensors
 260:ds1820/ds18x20-1.c **** 
 261:ds1820/ds18x20-1.c **** 	uart_puts_P( "\r" );
 262:ds1820/ds18x20-1.c **** 
 263:ds1820/ds18x20-1.c **** 	return DS18X20_OK;
 264:ds1820/ds18x20-1.c **** }
 265:ds1820/ds18x20-1.c **** 
 266:ds1820/ds18x20-1.c **** #endif /* DS18X20_VERBOSE */
 267:ds1820/ds18x20-1.c **** 
 268:ds1820/ds18x20-1.c **** #if DS18X20_VERBOSE
 269:ds1820/ds18x20-1.c **** #define uart_puts_P_verbose(s__) uart_puts_P(s__)
 270:ds1820/ds18x20-1.c **** #else
 271:ds1820/ds18x20-1.c **** #define uart_puts_P_verbose(s__)
 272:ds1820/ds18x20-1.c **** #endif
 273:ds1820/ds18x20-1.c **** 
 274:ds1820/ds18x20-1.c **** /*----------- end of "debug-functions" ---------------*/
 275:ds1820/ds18x20-1.c **** 
 276:ds1820/ds18x20-1.c **** /* find DS18X20 Sensors on 1-Wire-Bus
 277:ds1820/ds18x20-1.c ****  input/ouput: diff is the result of the last rom-search
 278:ds1820/ds18x20-1.c ****  *diff = OW_SEARCH_FIRST for first call
 279:ds1820/ds18x20-1.c ****  output: id is the rom-code of the sensor found */
 280:ds1820/ds18x20-1.c **** uint8_t DS18X20_find_sensor(uint8_t *diff, uint8_t id[]) {
 281:ds1820/ds18x20-1.c **** 	uint8_t go;
 282:ds1820/ds18x20-1.c **** 	uint8_t ret;
 283:ds1820/ds18x20-1.c **** 
 284:ds1820/ds18x20-1.c **** 	ret = DS18X20_OK;
 285:ds1820/ds18x20-1.c **** 	go = 1;
 286:ds1820/ds18x20-1.c **** 	do {
 287:ds1820/ds18x20-1.c **** 		*diff = ow_rom_search(*diff, &id[0]);
 288:ds1820/ds18x20-1.c **** 		if (*diff == OW_PRESENCE_ERR || *diff == OW_DATA_ERR || *diff == OW_LAST_DEVICE) {
 289:ds1820/ds18x20-1.c **** 			go = 0;
 290:ds1820/ds18x20-1.c **** 			ret = DS18X20_ERROR;
 291:ds1820/ds18x20-1.c **** 		} else {
 292:ds1820/ds18x20-1.c **** 			// if (id[0] == DS18B20_FAMILY_CODE || id[0] == DS18S20_FAMILY_CODE || id[0] == DS1822_FAMILY_CO
 293:ds1820/ds18x20-1.c **** 				go = 0;
 294:ds1820/ds18x20-1.c **** 			// }
 295:ds1820/ds18x20-1.c **** 		}
 296:ds1820/ds18x20-1.c **** 	} while (go);
 297:ds1820/ds18x20-1.c **** 
 298:ds1820/ds18x20-1.c **** 	return ret;
 299:ds1820/ds18x20-1.c **** }
 300:ds1820/ds18x20-1.c **** 
 301:ds1820/ds18x20-1.c **** /* get power status of DS18x20 
 302:ds1820/ds18x20-1.c ****  input:   id = rom_code
 303:ds1820/ds18x20-1.c ****  returns: DS18X20_POWER_EXTERN or DS18X20_POWER_PARASITE */
 304:ds1820/ds18x20-1.c **** uint8_t DS18X20_get_power_status(uint8_t id[]) {
 305:ds1820/ds18x20-1.c **** 	uint8_t pstat;
 306:ds1820/ds18x20-1.c **** 
 307:ds1820/ds18x20-1.c **** 	ow_reset();
 308:ds1820/ds18x20-1.c **** 	ow_command( DS18X20_READ_POWER_SUPPLY, id);
 309:ds1820/ds18x20-1.c **** 	pstat = ow_bit_io(1);
 310:ds1820/ds18x20-1.c **** 	ow_reset();
 311:ds1820/ds18x20-1.c **** 	return (pstat) ? DS18X20_POWER_EXTERN : DS18X20_POWER_PARASITE;
 312:ds1820/ds18x20-1.c **** }
 313:ds1820/ds18x20-1.c **** 
 314:ds1820/ds18x20-1.c **** /* start measurement (CONVERT_T) for all sensors if input id==NULL 
 315:ds1820/ds18x20-1.c ****  or for single sensor where id is the rom-code */
 316:ds1820/ds18x20-1.c **** uint8_t DS18X20_start_meas(uint8_t with_power_extern, uint8_t id[]) {
 317:ds1820/ds18x20-1.c **** 	uint8_t ret;
 318:ds1820/ds18x20-1.c **** 
 319:ds1820/ds18x20-1.c **** 	ow_reset();
 320:ds1820/ds18x20-1.c **** 	if (ow_input_pin_state()) { // only send if bus is "idle" = high
 321:ds1820/ds18x20-1.c **** 		if (with_power_extern != DS18X20_POWER_EXTERN) {
 322:ds1820/ds18x20-1.c **** 			ow_command_with_parasite_enable( DS18X20_CONVERT_T, id);
 323:ds1820/ds18x20-1.c **** 			/* not longer needed: ow_parasite_enable(); */
 324:ds1820/ds18x20-1.c **** 		} else {
 325:ds1820/ds18x20-1.c **** 			ow_command( DS18X20_CONVERT_T, id);
 326:ds1820/ds18x20-1.c **** 		}
 327:ds1820/ds18x20-1.c **** 		ret = DS18X20_OK;
 328:ds1820/ds18x20-1.c **** 	} else {
 329:ds1820/ds18x20-1.c **** 		uart_puts_P_verbose( "DS18X20_start_meas: Short Circuit!\r" );
 330:ds1820/ds18x20-1.c **** 		ret = DS18X20_START_FAIL;
 331:ds1820/ds18x20-1.c **** 	}
 332:ds1820/ds18x20-1.c **** 
 333:ds1820/ds18x20-1.c **** 	return ret;
 334:ds1820/ds18x20-1.c **** }
 335:ds1820/ds18x20-1.c **** 
 336:ds1820/ds18x20-1.c **** // returns 1 if conversion is in progress, 0 if finished
 337:ds1820/ds18x20-1.c **** // not available when parasite powered.
 338:ds1820/ds18x20-1.c **** uint8_t DS18X20_conversion_in_progress(void) {
 339:ds1820/ds18x20-1.c **** 	return ow_bit_io(1) ? DS18X20_CONVERSION_DONE : DS18X20_CONVERTING;
 340:ds1820/ds18x20-1.c **** }
 341:ds1820/ds18x20-1.c **** 
 342:ds1820/ds18x20-1.c **** static uint8_t read_scratchpad(uint8_t id[], uint8_t sp[], uint8_t n) {
 343:ds1820/ds18x20-1.c **** 	uint8_t i;
 344:ds1820/ds18x20-1.c **** 	uint8_t ret;
 345:ds1820/ds18x20-1.c **** 
 346:ds1820/ds18x20-1.c **** 	ow_command( DS18X20_READ, id);
 347:ds1820/ds18x20-1.c **** 	for (i = 0; i < n; i++) {
 348:ds1820/ds18x20-1.c **** 		sp[i] = ow_byte_rd();
 349:ds1820/ds18x20-1.c **** 	}
 350:ds1820/ds18x20-1.c **** 	if (crc8(&sp[0], DS18X20_SP_SIZE)) {
 351:ds1820/ds18x20-1.c **** 		ret = DS18X20_ERROR_CRC;
 352:ds1820/ds18x20-1.c **** 	} else {
 353:ds1820/ds18x20-1.c **** 		ret = DS18X20_OK;
 354:ds1820/ds18x20-1.c **** 	}
 355:ds1820/ds18x20-1.c **** 
 356:ds1820/ds18x20-1.c **** 	return ret;
 357:ds1820/ds18x20-1.c **** }
 358:ds1820/ds18x20-1.c **** 
 359:ds1820/ds18x20-1.c **** #if DS18X20_DECICELSIUS
 360:ds1820/ds18x20-1.c **** 
 361:ds1820/ds18x20-1.c **** /* convert scratchpad data to physical value in unit decicelsius */
 362:ds1820/ds18x20-1.c **** static int16_t DS18X20_raw_to_decicelsius(uint8_t familycode, uint8_t sp[]) {
  14               		.loc 1 362 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21 0000 FB01      		movw r30,r22
 363:ds1820/ds18x20-1.c **** 	uint16_t measure;
 364:ds1820/ds18x20-1.c **** 	uint8_t negative;
 365:ds1820/ds18x20-1.c **** 	int16_t decicelsius;
 366:ds1820/ds18x20-1.c **** 	uint16_t fract;
 367:ds1820/ds18x20-1.c **** 
 368:ds1820/ds18x20-1.c **** 	measure = sp[0] | (sp[1] << 8);
  22               		.loc 1 368 0
  23 0002 2181      		ldd r18,Z+1
  24 0004 30E0      		ldi r19,0
  25 0006 322F      		mov r19,r18
  26 0008 2227      		clr r18
  27 000a 9081      		ld r25,Z
  28 000c 292B      		or r18,r25
  29               	.LVL1:
 369:ds1820/ds18x20-1.c **** 	//measure = 0xFF5E; // test -10.125
 370:ds1820/ds18x20-1.c **** 	//measure = 0xFE6F; // test -25.0625
 371:ds1820/ds18x20-1.c **** 
 372:ds1820/ds18x20-1.c **** 	if (familycode == DS18S20_FAMILY_CODE) {   // 9 -> 12 bit if 18S20
  30               		.loc 1 372 0
  31 000e 8031      		cpi r24,lo8(16)
  32 0010 01F4      		brne .L2
 373:ds1820/ds18x20-1.c **** 		/* Extended measurements for DS18S20 contributed by Carsten Foss */
 374:ds1820/ds18x20-1.c **** 		measure &= (uint16_t) 0xfffe;   // Discard LSB, needed for later extended precicion calc
  33               		.loc 1 374 0
  34 0012 A901      		movw r20,r18
  35 0014 4E7F      		andi r20,254
  36               	.LVL2:
 375:ds1820/ds18x20-1.c **** 		measure <<= 3;                 // Convert to 12-bit, now degrees are in 1/16 degrees units
  37               		.loc 1 375 0
  38 0016 63E0      		ldi r22,3
  39               		1:
  40 0018 440F      		lsl r20
  41 001a 551F      		rol r21
  42 001c 6A95      		dec r22
  43 001e 01F4      		brne 1b
  44               	.LVL3:
 376:ds1820/ds18x20-1.c **** 		measure += (16 - sp[6]) - 4;   // Add the compensation and remember to subtract 0.25 degree (4/16
  45               		.loc 1 376 0
  46 0020 9681      		ldd r25,Z+6
  47 0022 2CE0      		ldi r18,lo8(12)
  48 0024 30E0      		ldi r19,0
  49 0026 291B      		sub r18,r25
  50 0028 3109      		sbc r19,__zero_reg__
  51 002a 240F      		add r18,r20
  52 002c 351F      		adc r19,r21
  53               	.LVL4:
  54               	.L2:
 377:ds1820/ds18x20-1.c **** 	}
 378:ds1820/ds18x20-1.c **** 
 379:ds1820/ds18x20-1.c **** 	// check for negative 
 380:ds1820/ds18x20-1.c **** 	if (measure & 0x8000) {
  55               		.loc 1 380 0
  56 002e 37FF      		sbrs r19,7
  57 0030 00C0      		rjmp .L12
  58               	.LVL5:
 381:ds1820/ds18x20-1.c **** 		negative = 1;       // mark negative
 382:ds1820/ds18x20-1.c **** 		measure ^= 0xffff;  // convert to positive => (twos complement)++
 383:ds1820/ds18x20-1.c **** 		measure++;
  59               		.loc 1 383 0
  60 0032 3195      		neg r19
  61 0034 2195      		neg r18
  62 0036 3109      		sbc r19,__zero_reg__
  63               	.LVL6:
 381:ds1820/ds18x20-1.c **** 		negative = 1;       // mark negative
  64               		.loc 1 381 0
  65 0038 A1E0      		ldi r26,lo8(1)
  66 003a 00C0      		rjmp .L3
  67               	.LVL7:
  68               	.L12:
 384:ds1820/ds18x20-1.c **** 	} else {
 385:ds1820/ds18x20-1.c **** 		negative = 0;
  69               		.loc 1 385 0
  70 003c A0E0      		ldi r26,0
  71               	.L3:
  72               	.LVL8:
 386:ds1820/ds18x20-1.c **** 	}
 387:ds1820/ds18x20-1.c **** 
 388:ds1820/ds18x20-1.c **** 	// clear undefined bits for DS18B20 != 12bit resolution
 389:ds1820/ds18x20-1.c **** 	if (familycode == DS18B20_FAMILY_CODE || familycode == DS1822_FAMILY_CODE) {
  73               		.loc 1 389 0
  74 003e 8832      		cpi r24,lo8(40)
  75 0040 01F0      		breq .L4
  76               		.loc 1 389 0 is_stmt 0 discriminator 1
  77 0042 8232      		cpi r24,lo8(34)
  78 0044 01F4      		brne .L5
  79               	.L4:
 390:ds1820/ds18x20-1.c **** 		switch (sp[DS18B20_CONF_REG] & DS18B20_RES_MASK) {
  80               		.loc 1 390 0 is_stmt 1
  81 0046 8481      		ldd r24,Z+4
  82               	.LVL9:
  83 0048 8076      		andi r24,lo8(96)
  84 004a 8032      		cpi r24,lo8(32)
  85 004c 01F0      		breq .L6
  86 004e 8034      		cpi r24,lo8(64)
  87 0050 01F0      		breq .L7
  88 0052 8111      		cpse r24,__zero_reg__
  89 0054 00C0      		rjmp .L5
 391:ds1820/ds18x20-1.c **** 		case DS18B20_9_BIT:
 392:ds1820/ds18x20-1.c **** 			measure &= ~(DS18B20_9_BIT_UNDF);
  90               		.loc 1 392 0
  91 0056 287F      		andi r18,248
  92               	.LVL10:
 393:ds1820/ds18x20-1.c **** 			break;
  93               		.loc 1 393 0
  94 0058 00C0      		rjmp .L5
  95               	.L6:
 394:ds1820/ds18x20-1.c **** 		case DS18B20_10_BIT:
 395:ds1820/ds18x20-1.c **** 			measure &= ~(DS18B20_10_BIT_UNDF);
  96               		.loc 1 395 0
  97 005a 2C7F      		andi r18,252
  98               	.LVL11:
 396:ds1820/ds18x20-1.c **** 			break;
  99               		.loc 1 396 0
 100 005c 00C0      		rjmp .L5
 101               	.L7:
 397:ds1820/ds18x20-1.c **** 		case DS18B20_11_BIT:
 398:ds1820/ds18x20-1.c **** 			measure &= ~(DS18B20_11_BIT_UNDF);
 102               		.loc 1 398 0
 103 005e 2E7F      		andi r18,254
 104               	.LVL12:
 105               	.L5:
 399:ds1820/ds18x20-1.c **** 			break;
 400:ds1820/ds18x20-1.c **** 		default:
 401:ds1820/ds18x20-1.c **** 			// 12 bit - all bits valid
 402:ds1820/ds18x20-1.c **** 			break;
 403:ds1820/ds18x20-1.c **** 		}
 404:ds1820/ds18x20-1.c **** 	}
 405:ds1820/ds18x20-1.c **** 
 406:ds1820/ds18x20-1.c **** 	decicelsius = (measure >> 4);
 106               		.loc 1 406 0
 107 0060 C901      		movw r24,r18
 108 0062 44E0      		ldi r20,4
 109               		1:
 110 0064 9695      		lsr r25
 111 0066 8795      		ror r24
 112 0068 4A95      		dec r20
 113 006a 01F4      		brne 1b
 114               	.LVL13:
 407:ds1820/ds18x20-1.c **** 	decicelsius *= 10;
 115               		.loc 1 407 0
 116 006c 6AE0      		ldi r22,lo8(10)
 117 006e 689F      		mul r22,r24
 118 0070 A001      		movw r20,r0
 119 0072 699F      		mul r22,r25
 120 0074 500D      		add r21,r0
 121 0076 1124      		clr __zero_reg__
 122               	.LVL14:
 408:ds1820/ds18x20-1.c **** 
 409:ds1820/ds18x20-1.c **** 	// decicelsius += ((measure & 0x000F) * 640 + 512) / 1024;
 410:ds1820/ds18x20-1.c **** 	// 625/1000 = 640/1024
 411:ds1820/ds18x20-1.c **** 	fract = (measure & 0x000F) * 640;
 123               		.loc 1 411 0
 124 0078 2F70      		andi r18,15
 125 007a 3327      		clr r19
 126               	.LVL15:
 127 007c 60E8      		ldi r22,lo8(-128)
 128 007e 72E0      		ldi r23,lo8(2)
 129 0080 269F      		mul r18,r22
 130 0082 C001      		movw r24,r0
 131 0084 279F      		mul r18,r23
 132 0086 900D      		add r25,r0
 133 0088 369F      		mul r19,r22
 134 008a 900D      		add r25,r0
 135 008c 1124      		clr r1
 136               	.LVL16:
 412:ds1820/ds18x20-1.c **** 	if (!negative) {
 137               		.loc 1 412 0
 138 008e A111      		cpse r26,__zero_reg__
 139 0090 00C0      		rjmp .L9
 413:ds1820/ds18x20-1.c **** 		fract += 512;
 140               		.loc 1 413 0
 141 0092 9E5F      		subi r25,-2
 142               	.LVL17:
 143               	.L9:
 414:ds1820/ds18x20-1.c **** 	}
 415:ds1820/ds18x20-1.c **** 	fract /= 1024;
 144               		.loc 1 415 0
 145 0094 9C01      		movw r18,r24
 146 0096 232F      		mov r18,r19
 147 0098 3327      		clr r19
 148 009a 2695      		lsr r18
 149 009c 2695      		lsr r18
 150               	.LVL18:
 416:ds1820/ds18x20-1.c **** 	decicelsius += fract;
 151               		.loc 1 416 0
 152 009e 240F      		add r18,r20
 153 00a0 351F      		adc r19,r21
 154               	.LVL19:
 417:ds1820/ds18x20-1.c **** 
 418:ds1820/ds18x20-1.c **** 	if (negative) {
 155               		.loc 1 418 0
 156 00a2 AA23      		tst r26
 157 00a4 01F0      		breq .L10
 419:ds1820/ds18x20-1.c **** 		decicelsius = -decicelsius;
 158               		.loc 1 419 0
 159 00a6 3195      		neg r19
 160 00a8 2195      		neg r18
 161 00aa 3109      		sbc r19,__zero_reg__
 162               	.LVL20:
 163               	.L10:
 420:ds1820/ds18x20-1.c **** 	}
 421:ds1820/ds18x20-1.c **** 
 422:ds1820/ds18x20-1.c **** 	if ( /* decicelsius == 850 || */decicelsius < -550 || decicelsius > 1250) {
 164               		.loc 1 422 0
 165 00ac C901      		movw r24,r18
 166 00ae 8A5D      		subi r24,-38
 167 00b0 9D4F      		sbci r25,-3
 168 00b2 8930      		cpi r24,9
 169 00b4 9740      		sbci r25,7
 170 00b6 00F0      		brlo .L13
 423:ds1820/ds18x20-1.c **** 		return DS18X20_INVALID_DECICELSIUS;
 171               		.loc 1 423 0
 172 00b8 80ED      		ldi r24,lo8(-48)
 173 00ba 97E0      		ldi r25,lo8(7)
 174 00bc 0895      		ret
 175               	.L13:
 176 00be C901      		movw r24,r18
 424:ds1820/ds18x20-1.c **** 	} else {
 425:ds1820/ds18x20-1.c **** 		return decicelsius;
 426:ds1820/ds18x20-1.c **** 	}
 427:ds1820/ds18x20-1.c **** }
 177               		.loc 1 427 0
 178 00c0 0895      		ret
 179               		.cfi_endproc
 180               	.LFE6:
 183               	read_scratchpad.constprop.0:
 184               	.LFB9:
 342:ds1820/ds18x20-1.c **** static uint8_t read_scratchpad(uint8_t id[], uint8_t sp[], uint8_t n) {
 185               		.loc 1 342 0
 186               		.cfi_startproc
 187               	.LVL21:
 188 00c2 FF92      		push r15
 189               	.LCFI0:
 190               		.cfi_def_cfa_offset 3
 191               		.cfi_offset 15, -2
 192 00c4 0F93      		push r16
 193               	.LCFI1:
 194               		.cfi_def_cfa_offset 4
 195               		.cfi_offset 16, -3
 196 00c6 1F93      		push r17
 197               	.LCFI2:
 198               		.cfi_def_cfa_offset 5
 199               		.cfi_offset 17, -4
 200 00c8 CF93      		push r28
 201               	.LCFI3:
 202               		.cfi_def_cfa_offset 6
 203               		.cfi_offset 28, -5
 204 00ca DF93      		push r29
 205               	.LCFI4:
 206               		.cfi_def_cfa_offset 7
 207               		.cfi_offset 29, -6
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 5 */
 211               	.L__stack_usage = 5
 212 00cc 062F      		mov r16,r22
 213 00ce F72E      		mov r15,r23
 214               	.LVL22:
 346:ds1820/ds18x20-1.c **** 	ow_command( DS18X20_READ, id);
 215               		.loc 1 346 0
 216 00d0 BC01      		movw r22,r24
 217               	.LVL23:
 218 00d2 8EEB      		ldi r24,lo8(-66)
 219               	.LVL24:
 220 00d4 00D0      		rcall ow_command
 221               	.LVL25:
 222 00d6 C02F      		mov r28,r16
 223 00d8 DF2D      		mov r29,r15
 224 00da 19E0      		ldi r17,lo8(9)
 225               	.LVL26:
 226               	.L23:
 348:ds1820/ds18x20-1.c **** 		sp[i] = ow_byte_rd();
 227               		.loc 1 348 0
 228 00dc 00D0      		rcall ow_byte_rd
 229               	.LVL27:
 230 00de 8993      		st Y+,r24
 231               	.LVL28:
 232 00e0 1150      		subi r17,lo8(-(-1))
 347:ds1820/ds18x20-1.c **** 	for (i = 0; i < n; i++) {
 233               		.loc 1 347 0
 234 00e2 01F4      		brne .L23
 350:ds1820/ds18x20-1.c **** 	if (crc8(&sp[0], DS18X20_SP_SIZE)) {
 235               		.loc 1 350 0
 236 00e4 69E0      		ldi r22,lo8(9)
 237 00e6 70E0      		ldi r23,0
 238 00e8 802F      		mov r24,r16
 239 00ea 9F2D      		mov r25,r15
 240 00ec 00D0      		rcall crc8
 241               	.LVL29:
 242 00ee 8823      		tst r24
 243 00f0 01F0      		breq .L25
 351:ds1820/ds18x20-1.c **** 		ret = DS18X20_ERROR_CRC;
 244               		.loc 1 351 0
 245 00f2 83E0      		ldi r24,lo8(3)
 246 00f4 00C0      		rjmp .L24
 247               	.L25:
 353:ds1820/ds18x20-1.c **** 		ret = DS18X20_OK;
 248               		.loc 1 353 0
 249 00f6 80E0      		ldi r24,0
 250               	.L24:
 251               	.LVL30:
 252               	/* epilogue start */
 357:ds1820/ds18x20-1.c **** }
 253               		.loc 1 357 0
 254 00f8 DF91      		pop r29
 255 00fa CF91      		pop r28
 256               	.LVL31:
 257 00fc 1F91      		pop r17
 258 00fe 0F91      		pop r16
 259 0100 FF90      		pop r15
 260 0102 0895      		ret
 261               		.cfi_endproc
 262               	.LFE9:
 264               	.global	DS18X20_find_sensor
 266               	DS18X20_find_sensor:
 267               	.LFB1:
 280:ds1820/ds18x20-1.c **** uint8_t DS18X20_find_sensor(uint8_t *diff, uint8_t id[]) {
 268               		.loc 1 280 0
 269               		.cfi_startproc
 270               	.LVL32:
 271 0104 CF93      		push r28
 272               	.LCFI5:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0106 DF93      		push r29
 276               	.LCFI6:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0108 EC01      		movw r28,r24
 284               	.LVL33:
 287:ds1820/ds18x20-1.c **** 		*diff = ow_rom_search(*diff, &id[0]);
 285               		.loc 1 287 0
 286 010a 8881      		ld r24,Y
 287               	.LVL34:
 288 010c 00D0      		rcall ow_rom_search
 289               	.LVL35:
 290 010e 8883      		st Y,r24
 291               	.LVL36:
 288:ds1820/ds18x20-1.c **** 		if (*diff == OW_PRESENCE_ERR || *diff == OW_DATA_ERR || *diff == OW_LAST_DEVICE) {
 292               		.loc 1 288 0
 293 0110 9FEF      		ldi r25,lo8(-1)
 294 0112 980F      		add r25,r24
 295 0114 81E0      		ldi r24,lo8(1)
 296               	.LVL37:
 297 0116 9D3F      		cpi r25,lo8(-3)
 298 0118 00F4      		brsh .L27
 299 011a 80E0      		ldi r24,0
 300               	.L27:
 301               	/* epilogue start */
 299:ds1820/ds18x20-1.c **** }
 302               		.loc 1 299 0
 303 011c DF91      		pop r29
 304 011e CF91      		pop r28
 305               	.LVL38:
 306 0120 0895      		ret
 307               		.cfi_endproc
 308               	.LFE1:
 310               	.global	DS18X20_get_power_status
 312               	DS18X20_get_power_status:
 313               	.LFB2:
 304:ds1820/ds18x20-1.c **** uint8_t DS18X20_get_power_status(uint8_t id[]) {
 314               		.loc 1 304 0
 315               		.cfi_startproc
 316               	.LVL39:
 317 0122 CF93      		push r28
 318               	.LCFI7:
 319               		.cfi_def_cfa_offset 3
 320               		.cfi_offset 28, -2
 321 0124 DF93      		push r29
 322               	.LCFI8:
 323               		.cfi_def_cfa_offset 4
 324               		.cfi_offset 29, -3
 325               	/* prologue: function */
 326               	/* frame size = 0 */
 327               	/* stack size = 2 */
 328               	.L__stack_usage = 2
 329 0126 EC01      		movw r28,r24
 307:ds1820/ds18x20-1.c **** 	ow_reset();
 330               		.loc 1 307 0
 331 0128 00D0      		rcall ow_reset
 332               	.LVL40:
 308:ds1820/ds18x20-1.c **** 	ow_command( DS18X20_READ_POWER_SUPPLY, id);
 333               		.loc 1 308 0
 334 012a BE01      		movw r22,r28
 335 012c 84EB      		ldi r24,lo8(-76)
 336 012e 00D0      		rcall ow_command
 337               	.LVL41:
 309:ds1820/ds18x20-1.c **** 	pstat = ow_bit_io(1);
 338               		.loc 1 309 0
 339 0130 81E0      		ldi r24,lo8(1)
 340 0132 00D0      		rcall ow_bit_io
 341               	.LVL42:
 342 0134 C82F      		mov r28,r24
 343               	.LVL43:
 310:ds1820/ds18x20-1.c **** 	ow_reset();
 344               		.loc 1 310 0
 345 0136 00D0      		rcall ow_reset
 346               	.LVL44:
 311:ds1820/ds18x20-1.c **** 	return (pstat) ? DS18X20_POWER_EXTERN : DS18X20_POWER_PARASITE;
 347               		.loc 1 311 0
 348 0138 81E0      		ldi r24,lo8(1)
 349 013a C111      		cpse r28,__zero_reg__
 350 013c 00C0      		rjmp .L29
 351 013e 80E0      		ldi r24,0
 352               	.L29:
 353               	/* epilogue start */
 312:ds1820/ds18x20-1.c **** }
 354               		.loc 1 312 0
 355 0140 DF91      		pop r29
 356 0142 CF91      		pop r28
 357               	.LVL45:
 358 0144 0895      		ret
 359               		.cfi_endproc
 360               	.LFE2:
 362               	.global	DS18X20_start_meas
 364               	DS18X20_start_meas:
 365               	.LFB3:
 316:ds1820/ds18x20-1.c **** uint8_t DS18X20_start_meas(uint8_t with_power_extern, uint8_t id[]) {
 366               		.loc 1 316 0
 367               		.cfi_startproc
 368               	.LVL46:
 369 0146 1F93      		push r17
 370               	.LCFI9:
 371               		.cfi_def_cfa_offset 3
 372               		.cfi_offset 17, -2
 373 0148 CF93      		push r28
 374               	.LCFI10:
 375               		.cfi_def_cfa_offset 4
 376               		.cfi_offset 28, -3
 377 014a DF93      		push r29
 378               	.LCFI11:
 379               		.cfi_def_cfa_offset 5
 380               		.cfi_offset 29, -4
 381 014c 00D0      		rcall .
 382               	.LCFI12:
 383               		.cfi_def_cfa_offset 7
 384 014e CDB7      		in r28,__SP_L__
 385 0150 DEB7      		in r29,__SP_H__
 386               	.LCFI13:
 387               		.cfi_def_cfa_register 28
 388               	/* prologue: function */
 389               	/* frame size = 2 */
 390               	/* stack size = 5 */
 391               	.L__stack_usage = 5
 392 0152 182F      		mov r17,r24
 319:ds1820/ds18x20-1.c **** 	ow_reset();
 393               		.loc 1 319 0
 394 0154 6983      		std Y+1,r22
 395 0156 7A83      		std Y+2,r23
 396 0158 00D0      		rcall ow_reset
 397               	.LVL47:
 320:ds1820/ds18x20-1.c **** 	if (ow_input_pin_state()) { // only send if bus is "idle" = high
 398               		.loc 1 320 0
 399 015a 00D0      		rcall ow_input_pin_state
 400               	.LVL48:
 401 015c 6981      		ldd r22,Y+1
 402 015e 7A81      		ldd r23,Y+2
 403 0160 8823      		tst r24
 404 0162 01F0      		breq .L33
 322:ds1820/ds18x20-1.c **** 			ow_command_with_parasite_enable( DS18X20_CONVERT_T, id);
 405               		.loc 1 322 0
 406 0164 84E4      		ldi r24,lo8(68)
 321:ds1820/ds18x20-1.c **** 		if (with_power_extern != DS18X20_POWER_EXTERN) {
 407               		.loc 1 321 0
 408 0166 1130      		cpi r17,lo8(1)
 409 0168 01F0      		breq .L32
 322:ds1820/ds18x20-1.c **** 			ow_command_with_parasite_enable( DS18X20_CONVERT_T, id);
 410               		.loc 1 322 0
 411 016a 00D0      		rcall ow_command_with_parasite_enable
 412               	.LVL49:
 413 016c 00C0      		rjmp .L34
 414               	.L32:
 325:ds1820/ds18x20-1.c **** 			ow_command( DS18X20_CONVERT_T, id);
 415               		.loc 1 325 0
 416 016e 00D0      		rcall ow_command
 417               	.LVL50:
 418               	.L34:
 327:ds1820/ds18x20-1.c **** 		ret = DS18X20_OK;
 419               		.loc 1 327 0
 420 0170 80E0      		ldi r24,0
 421 0172 00C0      		rjmp .L31
 422               	.L33:
 330:ds1820/ds18x20-1.c **** 		ret = DS18X20_START_FAIL;
 423               		.loc 1 330 0
 424 0174 82E0      		ldi r24,lo8(2)
 425               	.L31:
 426               	.LVL51:
 427               	/* epilogue start */
 334:ds1820/ds18x20-1.c **** }
 428               		.loc 1 334 0
 429 0176 0F90      		pop __tmp_reg__
 430 0178 0F90      		pop __tmp_reg__
 431 017a DF91      		pop r29
 432 017c CF91      		pop r28
 433 017e 1F91      		pop r17
 434               	.LVL52:
 435 0180 0895      		ret
 436               		.cfi_endproc
 437               	.LFE3:
 439               	.global	DS18X20_conversion_in_progress
 441               	DS18X20_conversion_in_progress:
 442               	.LFB4:
 338:ds1820/ds18x20-1.c **** uint8_t DS18X20_conversion_in_progress(void) {
 443               		.loc 1 338 0
 444               		.cfi_startproc
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 0 */
 448               	.L__stack_usage = 0
 339:ds1820/ds18x20-1.c **** 	return ow_bit_io(1) ? DS18X20_CONVERSION_DONE : DS18X20_CONVERTING;
 449               		.loc 1 339 0
 450 0182 81E0      		ldi r24,lo8(1)
 451 0184 00D0      		rcall ow_bit_io
 452               	.LVL53:
 453 0186 91E0      		ldi r25,lo8(1)
 454 0188 8111      		cpse r24,__zero_reg__
 455 018a 90E0      		ldi r25,0
 456               	.L36:
 340:ds1820/ds18x20-1.c **** }
 457               		.loc 1 340 0
 458 018c 892F      		mov r24,r25
 459 018e 0895      		ret
 460               		.cfi_endproc
 461               	.LFE4:
 463               	.global	DS18X20_read_decicelsius
 465               	DS18X20_read_decicelsius:
 466               	.LFB7:
 428:ds1820/ds18x20-1.c **** //
 429:ds1820/ds18x20-1.c **** ///* format decicelsius-value into string, itoa method inspired
 430:ds1820/ds18x20-1.c **** // by code from Chris Takahashi for the MSP430 libc, BSD-license
 431:ds1820/ds18x20-1.c **** // modifications mthomas: variable-types, fixed radix 10, use div(),
 432:ds1820/ds18x20-1.c **** // insert decimal-point */
 433:ds1820/ds18x20-1.c **** //uint8_t DS18X20_format_from_decicelsius(int16_t decicelsius, char str[], uint8_t n) {
 434:ds1820/ds18x20-1.c **** //	uint8_t sign = 0;
 435:ds1820/ds18x20-1.c **** //	char temp[7];
 436:ds1820/ds18x20-1.c **** //	int8_t temp_loc = 0;
 437:ds1820/ds18x20-1.c **** //	uint8_t str_loc = 0;
 438:ds1820/ds18x20-1.c **** //	div_t dt;
 439:ds1820/ds18x20-1.c **** //	uint8_t ret;
 440:ds1820/ds18x20-1.c **** //
 441:ds1820/ds18x20-1.c **** //	// range from -550:-55.0�C to 1250:+125.0�C -> min. 6+1 chars
 442:ds1820/ds18x20-1.c **** //	if (n >= (6 + 1) && decicelsius > -1000 && decicelsius < 10000) {
 443:ds1820/ds18x20-1.c **** //
 444:ds1820/ds18x20-1.c **** //		if (decicelsius < 0) {
 445:ds1820/ds18x20-1.c **** //			sign = 1;
 446:ds1820/ds18x20-1.c **** //			decicelsius = -decicelsius;
 447:ds1820/ds18x20-1.c **** //		}
 448:ds1820/ds18x20-1.c **** //
 449:ds1820/ds18x20-1.c **** //		// construct a backward string of the number.
 450:ds1820/ds18x20-1.c **** //		do {
 451:ds1820/ds18x20-1.c **** //			dt = div(decicelsius, 10);
 452:ds1820/ds18x20-1.c **** //			temp[temp_loc++] = dt.rem + '0';
 453:ds1820/ds18x20-1.c **** //			decicelsius = dt.quot;
 454:ds1820/ds18x20-1.c **** //		} while (decicelsius > 0);
 455:ds1820/ds18x20-1.c **** //
 456:ds1820/ds18x20-1.c **** //		if (sign) {
 457:ds1820/ds18x20-1.c **** //			temp[temp_loc] = '-';
 458:ds1820/ds18x20-1.c **** //		} else {
 459:ds1820/ds18x20-1.c **** //			///temp_loc--;
 460:ds1820/ds18x20-1.c **** //			temp[temp_loc] = '+';
 461:ds1820/ds18x20-1.c **** //		}
 462:ds1820/ds18x20-1.c **** //
 463:ds1820/ds18x20-1.c **** //		// reverse the string.into the output
 464:ds1820/ds18x20-1.c **** //		while (temp_loc >= 0) {
 465:ds1820/ds18x20-1.c **** //			str[str_loc++] = temp[(uint8_t) temp_loc--];
 466:ds1820/ds18x20-1.c **** //			if (temp_loc == 0) {
 467:ds1820/ds18x20-1.c **** //				str[str_loc++] = DS18X20_DECIMAL_CHAR;
 468:ds1820/ds18x20-1.c **** //			}
 469:ds1820/ds18x20-1.c **** //		}
 470:ds1820/ds18x20-1.c **** //		str[str_loc] = '\0';
 471:ds1820/ds18x20-1.c **** //
 472:ds1820/ds18x20-1.c **** //		ret = DS18X20_OK;
 473:ds1820/ds18x20-1.c **** //	} else {
 474:ds1820/ds18x20-1.c **** //		ret = DS18X20_ERROR;
 475:ds1820/ds18x20-1.c **** //	}
 476:ds1820/ds18x20-1.c **** //
 477:ds1820/ds18x20-1.c **** //	return ret;
 478:ds1820/ds18x20-1.c **** //}
 479:ds1820/ds18x20-1.c **** 
 480:ds1820/ds18x20-1.c **** /* reads temperature (scratchpad) of sensor with rom-code id
 481:ds1820/ds18x20-1.c ****  output: decicelsius
 482:ds1820/ds18x20-1.c ****  returns DS18X20_OK on success */
 483:ds1820/ds18x20-1.c **** uint8_t DS18X20_read_decicelsius(uint8_t id[], int16_t *decicelsius) {
 467               		.loc 1 483 0
 468               		.cfi_startproc
 469               	.LVL54:
 470 0190 DF92      		push r13
 471               	.LCFI14:
 472               		.cfi_def_cfa_offset 3
 473               		.cfi_offset 13, -2
 474 0192 EF92      		push r14
 475               	.LCFI15:
 476               		.cfi_def_cfa_offset 4
 477               		.cfi_offset 14, -3
 478 0194 FF92      		push r15
 479               	.LCFI16:
 480               		.cfi_def_cfa_offset 5
 481               		.cfi_offset 15, -4
 482 0196 0F93      		push r16
 483               	.LCFI17:
 484               		.cfi_def_cfa_offset 6
 485               		.cfi_offset 16, -5
 486 0198 1F93      		push r17
 487               	.LCFI18:
 488               		.cfi_def_cfa_offset 7
 489               		.cfi_offset 17, -6
 490 019a CF93      		push r28
 491               	.LCFI19:
 492               		.cfi_def_cfa_offset 8
 493               		.cfi_offset 28, -7
 494 019c DF93      		push r29
 495               	.LCFI20:
 496               		.cfi_def_cfa_offset 9
 497               		.cfi_offset 29, -8
 498 019e CDB7      		in r28,__SP_L__
 499 01a0 DEB7      		in r29,__SP_H__
 500               	.LCFI21:
 501               		.cfi_def_cfa_register 28
 502 01a2 2997      		sbiw r28,9
 503               	.LCFI22:
 504               		.cfi_def_cfa_offset 18
 505 01a4 0FB6      		in __tmp_reg__,__SREG__
 506 01a6 F894      		cli
 507 01a8 DEBF      		out __SP_H__,r29
 508 01aa 0FBE      		out __SREG__,__tmp_reg__
 509 01ac CDBF      		out __SP_L__,r28
 510               	/* prologue: function */
 511               	/* frame size = 9 */
 512               	/* stack size = 16 */
 513               	.L__stack_usage = 16
 514 01ae 8C01      		movw r16,r24
 515 01b0 7B01      		movw r14,r22
 484:ds1820/ds18x20-1.c **** 	uint8_t sp[DS18X20_SP_SIZE];
 485:ds1820/ds18x20-1.c **** 	uint8_t ret;
 486:ds1820/ds18x20-1.c **** 
 487:ds1820/ds18x20-1.c **** 	ow_reset();
 516               		.loc 1 487 0
 517 01b2 00D0      		rcall ow_reset
 518               	.LVL55:
 488:ds1820/ds18x20-1.c **** 	ret = read_scratchpad(id, sp, DS18X20_SP_SIZE);
 519               		.loc 1 488 0
 520 01b4 BE01      		movw r22,r28
 521 01b6 6F5F      		subi r22,-1
 522 01b8 7F4F      		sbci r23,-1
 523 01ba C801      		movw r24,r16
 524 01bc 00D0      		rcall read_scratchpad.constprop.0
 525               	.LVL56:
 526 01be D82E      		mov r13,r24
 527               	.LVL57:
 489:ds1820/ds18x20-1.c **** 	if (ret == DS18X20_OK) {
 528               		.loc 1 489 0
 529 01c0 8111      		cpse r24,__zero_reg__
 530 01c2 00C0      		rjmp .L41
 490:ds1820/ds18x20-1.c **** 		*decicelsius = DS18X20_raw_to_decicelsius(id[0], sp);
 531               		.loc 1 490 0
 532 01c4 BE01      		movw r22,r28
 533 01c6 6F5F      		subi r22,-1
 534 01c8 7F4F      		sbci r23,-1
 535 01ca F801      		movw r30,r16
 536 01cc 8081      		ld r24,Z
 537 01ce 00D0      		rcall DS18X20_raw_to_decicelsius
 538               	.LVL58:
 539 01d0 F701      		movw r30,r14
 540 01d2 9183      		std Z+1,r25
 541 01d4 8083      		st Z,r24
 542               	.L41:
 491:ds1820/ds18x20-1.c **** 	}
 492:ds1820/ds18x20-1.c **** 	return ret;
 493:ds1820/ds18x20-1.c **** }
 543               		.loc 1 493 0
 544 01d6 8D2D      		mov r24,r13
 545               	/* epilogue start */
 546 01d8 2996      		adiw r28,9
 547 01da 0FB6      		in __tmp_reg__,__SREG__
 548 01dc F894      		cli
 549 01de DEBF      		out __SP_H__,r29
 550 01e0 0FBE      		out __SREG__,__tmp_reg__
 551 01e2 CDBF      		out __SP_L__,r28
 552 01e4 DF91      		pop r29
 553 01e6 CF91      		pop r28
 554 01e8 1F91      		pop r17
 555 01ea 0F91      		pop r16
 556               	.LVL59:
 557 01ec FF90      		pop r15
 558 01ee EF90      		pop r14
 559               	.LVL60:
 560 01f0 DF90      		pop r13
 561               	.LVL61:
 562 01f2 0895      		ret
 563               		.cfi_endproc
 564               	.LFE7:
 566               	.global	DS18X20_read_decicelsius_single
 568               	DS18X20_read_decicelsius_single:
 569               	.LFB8:
 494:ds1820/ds18x20-1.c **** 
 495:ds1820/ds18x20-1.c **** /* reads temperature (scratchpad) of sensor without id (single sensor)
 496:ds1820/ds18x20-1.c ****  output: decicelsius
 497:ds1820/ds18x20-1.c ****  returns DS18X20_OK on success */
 498:ds1820/ds18x20-1.c **** uint8_t DS18X20_read_decicelsius_single(uint8_t familycode, int16_t *decicelsius) {
 570               		.loc 1 498 0
 571               		.cfi_startproc
 572               	.LVL62:
 573 01f4 EF92      		push r14
 574               	.LCFI23:
 575               		.cfi_def_cfa_offset 3
 576               		.cfi_offset 14, -2
 577 01f6 FF92      		push r15
 578               	.LCFI24:
 579               		.cfi_def_cfa_offset 4
 580               		.cfi_offset 15, -3
 581 01f8 0F93      		push r16
 582               	.LCFI25:
 583               		.cfi_def_cfa_offset 5
 584               		.cfi_offset 16, -4
 585 01fa 1F93      		push r17
 586               	.LCFI26:
 587               		.cfi_def_cfa_offset 6
 588               		.cfi_offset 17, -5
 589 01fc CF93      		push r28
 590               	.LCFI27:
 591               		.cfi_def_cfa_offset 7
 592               		.cfi_offset 28, -6
 593 01fe DF93      		push r29
 594               	.LCFI28:
 595               		.cfi_def_cfa_offset 8
 596               		.cfi_offset 29, -7
 597 0200 CDB7      		in r28,__SP_L__
 598 0202 DEB7      		in r29,__SP_H__
 599               	.LCFI29:
 600               		.cfi_def_cfa_register 28
 601 0204 2997      		sbiw r28,9
 602               	.LCFI30:
 603               		.cfi_def_cfa_offset 17
 604 0206 0FB6      		in __tmp_reg__,__SREG__
 605 0208 F894      		cli
 606 020a DEBF      		out __SP_H__,r29
 607 020c 0FBE      		out __SREG__,__tmp_reg__
 608 020e CDBF      		out __SP_L__,r28
 609               	/* prologue: function */
 610               	/* frame size = 9 */
 611               	/* stack size = 15 */
 612               	.L__stack_usage = 15
 613 0210 E82E      		mov r14,r24
 614 0212 8B01      		movw r16,r22
 499:ds1820/ds18x20-1.c **** 	uint8_t sp[DS18X20_SP_SIZE];
 500:ds1820/ds18x20-1.c **** 	uint8_t ret;
 501:ds1820/ds18x20-1.c **** 
 502:ds1820/ds18x20-1.c **** 	ret = read_scratchpad( NULL, sp, DS18X20_SP_SIZE);
 615               		.loc 1 502 0
 616 0214 BE01      		movw r22,r28
 617               	.LVL63:
 618 0216 6F5F      		subi r22,-1
 619 0218 7F4F      		sbci r23,-1
 620 021a 80E0      		ldi r24,0
 621 021c 90E0      		ldi r25,0
 622               	.LVL64:
 623 021e 00D0      		rcall read_scratchpad.constprop.0
 624               	.LVL65:
 625 0220 F82E      		mov r15,r24
 626               	.LVL66:
 503:ds1820/ds18x20-1.c **** 	if (ret == DS18X20_OK) {
 627               		.loc 1 503 0
 628 0222 8111      		cpse r24,__zero_reg__
 629 0224 00C0      		rjmp .L43
 504:ds1820/ds18x20-1.c **** 		*decicelsius = DS18X20_raw_to_decicelsius(familycode, sp);
 630               		.loc 1 504 0
 631 0226 BE01      		movw r22,r28
 632 0228 6F5F      		subi r22,-1
 633 022a 7F4F      		sbci r23,-1
 634 022c 8E2D      		mov r24,r14
 635 022e 00D0      		rcall DS18X20_raw_to_decicelsius
 636               	.LVL67:
 637 0230 F801      		movw r30,r16
 638 0232 9183      		std Z+1,r25
 639 0234 8083      		st Z,r24
 640               	.L43:
 505:ds1820/ds18x20-1.c **** 	}
 506:ds1820/ds18x20-1.c **** 	return ret;
 507:ds1820/ds18x20-1.c **** }
 641               		.loc 1 507 0
 642 0236 8F2D      		mov r24,r15
 643               	/* epilogue start */
 644 0238 2996      		adiw r28,9
 645 023a 0FB6      		in __tmp_reg__,__SREG__
 646 023c F894      		cli
 647 023e DEBF      		out __SP_H__,r29
 648 0240 0FBE      		out __SREG__,__tmp_reg__
 649 0242 CDBF      		out __SP_L__,r28
 650 0244 DF91      		pop r29
 651 0246 CF91      		pop r28
 652 0248 1F91      		pop r17
 653 024a 0F91      		pop r16
 654               	.LVL68:
 655 024c FF90      		pop r15
 656               	.LVL69:
 657 024e EF90      		pop r14
 658               	.LVL70:
 659 0250 0895      		ret
 660               		.cfi_endproc
 661               	.LFE8:
 663               	.Letext0:
 664               		.file 2 "/usr/lib/avr/include/stdint.h"
 665               		.file 3 "ds1820/crc8.h"
 666               		.file 4 "ds1820/onewire.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ds18x20-1.c
     /tmp/ccHTEdEf.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccHTEdEf.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccHTEdEf.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccHTEdEf.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccHTEdEf.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccHTEdEf.s:11     .text:0000000000000000 DS18X20_raw_to_decicelsius
     /tmp/ccHTEdEf.s:183    .text:00000000000000c2 read_scratchpad.constprop.0
     /tmp/ccHTEdEf.s:266    .text:0000000000000104 DS18X20_find_sensor
     /tmp/ccHTEdEf.s:312    .text:0000000000000122 DS18X20_get_power_status
     /tmp/ccHTEdEf.s:364    .text:0000000000000146 DS18X20_start_meas
     /tmp/ccHTEdEf.s:441    .text:0000000000000182 DS18X20_conversion_in_progress
     /tmp/ccHTEdEf.s:465    .text:0000000000000190 DS18X20_read_decicelsius
     /tmp/ccHTEdEf.s:568    .text:00000000000001f4 DS18X20_read_decicelsius_single

UNDEFINED SYMBOLS
ow_command
ow_byte_rd
crc8
ow_rom_search
ow_reset
ow_bit_io
ow_input_pin_state
ow_command_with_parasite_enable

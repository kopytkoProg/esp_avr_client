   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	cmp_cmd_of_msg
  12               	cmp_cmd_of_msg:
  13               	.LFB8:
  14               		.file 1 "main.c"
   1:main.c        **** #include <avr/io.h>
   2:main.c        **** #include <util/delay.h>
   3:main.c        **** #include <stdio.h>
   4:main.c        **** #include <stdlib.h>
   5:main.c        **** #include <string.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include "uart/uart.h"
   8:main.c        **** #include "esp/esp.h"
   9:main.c        **** #include "commands.h"
  10:main.c        **** #include "ds1820/onewire.h"
  11:main.c        **** #include "ds1820/ds18x20.h"
  12:main.c        **** #include "main.h"
  13:main.c        **** #include "lcd/hd44780.h"
  14:main.c        **** 
  15:main.c        **** static uint8_t sensor_id[NUM_SENSORS][OW_ROMCODE_SIZE];
  16:main.c        **** static uint8_t nfound = 0;
  17:main.c        **** static int16_t temp[NUM_SENSORS];
  18:main.c        **** 
  19:main.c        **** static void update_temp(void) {
  20:main.c        **** 	uint8_t i;
  21:main.c        **** 
  22:main.c        **** 	if (!nfound) {
  23:main.c        **** 		uint8_t dnum = OW_SEARCH_FIRST;
  24:main.c        **** 
  25:main.c        **** 		ow_reset();
  26:main.c        **** 
  27:main.c        **** 		while (dnum != OW_LAST_DEVICE) {
  28:main.c        **** 			if (nfound) memcpy(sensor_id[nfound], sensor_id[nfound - 1], OW_ROMCODE_SIZE);
  29:main.c        **** 			dnum = ow_rom_search(dnum, sensor_id[nfound]);
  30:main.c        **** 			esp_debugf("Found: "IDSTR", dnum: %u", ID2STR(sensor_id[nfound]), dnum);
  31:main.c        **** 			nfound++;
  32:main.c        **** 		}
  33:main.c        **** 
  34:main.c        **** 		if (!nfound) {
  35:main.c        **** 			esp_debug("Error: No sensor founds!");
  36:main.c        **** 			lcd_clrscr();
  37:main.c        **** 			lcd_putsf("No sensor found");
  38:main.c        **** 			return;
  39:main.c        **** 		}
  40:main.c        **** 
  41:main.c        **** 		esp_debugf("Found: %u", nfound);
  42:main.c        **** 
  43:main.c        **** 	}
  44:main.c        **** 
  45:main.c        **** 	for (i = 0; i < nfound; i++) {
  46:main.c        **** 		if (DS18X20_conversion_in_progress()) return;
  47:main.c        **** 		DS18X20_read_decicelsius(&sensor_id[i][0], &temp[i]);
  48:main.c        **** 	}
  49:main.c        **** 
  50:main.c        **** 	lcd_clrscr();
  51:main.c        **** 
  52:main.c        **** 	if (nfound == 1) {
  53:main.c        **** 		lcd_putsf("t1:%d,%d", temp[0] / 10, temp[0] % 10);
  54:main.c        **** 	} else if (nfound == 2) {
  55:main.c        **** 		lcd_putsf("t1:%d,%d", temp[0] / 10, temp[0] % 10);
  56:main.c        **** 		lcd_goto(0x40);
  57:main.c        **** 		lcd_putsf("t2:%d,%d", temp[1] / 10, temp[1] % 10);
  58:main.c        **** 	} else if (nfound == 3) {
  59:main.c        **** 		lcd_putsf("t1:%d,%d t2:%d,%d", temp[0] / 10, temp[0] % 10, temp[1] / 10, temp[1] % 10);
  60:main.c        **** 		lcd_goto(0x40);
  61:main.c        **** 		lcd_putsf("t3:%d,%d", temp[2] / 10, temp[2] % 10);
  62:main.c        **** 	}
  63:main.c        **** 	// esp_debugf("t1: %d, t2: %d, t3: %d", temp[0], temp[1], temp[2]);
  64:main.c        **** 	DS18X20_start_meas( DS18X20_POWER_EXTERN, NULL);
  65:main.c        **** 
  66:main.c        **** }
  67:main.c        **** 
  68:main.c        **** /**
  69:main.c        ****  * '{<cmd>:<param>, <param>, ...}'
  70:main.c        ****  * '{<cmd>}'
  71:main.c        ****  */
  72:main.c        **** uint8_t cmp_cmd_of_msg(char *msg1, char *msg2) {
  15               		.loc 1 72 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  73:main.c        **** 	uint8_t i = 0;
  74:main.c        **** 
  75:main.c        **** 	while (*msg1 == '}' && *msg1 == ':' && *msg1 == *msg2) {
  76:main.c        **** 		i++;
  77:main.c        **** 		msg1++;
  78:main.c        **** 		msg2++;
  79:main.c        **** 	}
  80:main.c        **** 	return *msg1 == *msg2 ? 0 : i;
  81:main.c        **** }
  22               		.loc 1 81 0
  23 0000 80E0      		ldi r24,0
  24               	.LVL1:
  25 0002 0895      		ret
  26               		.cfi_endproc
  27               	.LFE8:
  29               		.section	.rodata.str1.1,"aMS",@progbits,1
  30               	.LC0:
  31 0000 4865 6C6C 		.string	"Hello world"
  31      6F20 776F 
  31      726C 6400 
  32               	.LC1:
  33 000c 466F 756E 		.string	"Found: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, dnum: %u"
  33      643A 2025 
  33      3032 783A 
  33      2530 3278 
  33      3A25 3032 
  34               	.LC2:
  35 0045 4572 726F 		.string	"Error: No sensor founds!"
  35      723A 204E 
  35      6F20 7365 
  35      6E73 6F72 
  35      2066 6F75 
  36               	.LC3:
  37 005e 4E6F 2073 		.string	"No sensor found"
  37      656E 736F 
  37      7220 666F 
  37      756E 6400 
  38               	.LC4:
  39 006e 466F 756E 		.string	"Found: %u"
  39      643A 2025 
  39      7500 
  40               	.LC5:
  41 0078 7431 3A25 		.string	"t1:%d,%d"
  41      642C 2564 
  41      00
  42               	.LC6:
  43 0081 7432 3A25 		.string	"t2:%d,%d"
  43      642C 2564 
  43      00
  44               	.LC7:
  45 008a 7431 3A25 		.string	"t1:%d,%d t2:%d,%d"
  45      642C 2564 
  45      2074 323A 
  45      2564 2C25 
  45      6400 
  46               	.LC8:
  47 009c 7433 3A25 		.string	"t3:%d,%d"
  47      642C 2564 
  47      00
  48               	.LC9:
  49 00a5 7B68 656C 		.string	"{hello-avr}"
  49      6C6F 2D61 
  49      7672 7D00 
  50               	.LC10:
  51 00b1 7B67 6574 		.string	"{get-sensor-id-avr}"
  51      2D73 656E 
  51      736F 722D 
  51      6964 2D61 
  51      7672 7D00 
  52               	.LC11:
  53 00c5 00        		.string	""
  54               	.LC12:
  55 00c6 2530 3278 		.string	"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x"
  55      3A25 3032 
  55      783A 2530 
  55      3278 3A25 
  55      3032 783A 
  56               	.LC13:
  57 00ee 2530 3278 		.string	"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x"
  57      3A25 3032 
  57      783A 2530 
  57      3278 3A25 
  57      3032 783A 
  58               	.LC14:
  59 013f 2530 3278 		.string	"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, %02x:%0
  59      3A25 3032 
  59      783A 2530 
  59      3278 3A25 
  59      3032 783A 
  60               	.LC15:
  61 01b9 2569 00   		.string	"%i"
  62               	.LC16:
  63 01bc 4572 723A 		.string	"Err: id not found"
  63      2069 6420 
  63      6E6F 7420 
  63      666F 756E 
  63      6400 
  64               		.section	.text.startup,"ax",@progbits
  65               	.global	main
  67               	main:
  68               	.LFB9:
  82:main.c        **** 
  83:main.c        **** int main(void) {
  69               		.loc 1 83 0
  70               		.cfi_startproc
  71 0000 CF93      		push r28
  72               	.LCFI0:
  73               		.cfi_def_cfa_offset 3
  74               		.cfi_offset 28, -2
  75 0002 DF93      		push r29
  76               	.LCFI1:
  77               		.cfi_def_cfa_offset 4
  78               		.cfi_offset 29, -3
  79 0004 CDB7      		in r28,__SP_L__
  80 0006 DEB7      		in r29,__SP_H__
  81               	.LCFI2:
  82               		.cfi_def_cfa_register 28
  83 0008 CE57      		subi r28,126
  84 000a D109      		sbc r29,__zero_reg__
  85               	.LCFI3:
  86               		.cfi_def_cfa_offset 130
  87 000c 0FB6      		in __tmp_reg__,__SREG__
  88 000e F894      		cli
  89 0010 DEBF      		out __SP_H__,r29
  90 0012 0FBE      		out __SREG__,__tmp_reg__
  91 0014 CDBF      		out __SP_L__,r28
  92               	/* prologue: function */
  93               	/* frame size = 126 */
  94               	/* stack size = 128 */
  95               	.L__stack_usage = 128
  96               	.LVL2:
  97               	.LBB15:
  98               	.LBB16:
  99               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 100               		.loc 2 164 0
 101 0016 2FEF      		ldi r18,lo8(1599999)
 102 0018 39E6      		ldi r19,hi8(1599999)
 103 001a 48E1      		ldi r20,hlo8(1599999)
 104 001c 2150      		1: subi r18,1
 105 001e 3040      		sbci r19,0
 106 0020 4040      		sbci r20,0
 107 0022 01F4      		brne 1b
 108 0024 00C0      		rjmp .
 109 0026 0000      		nop
 110               	.LBE16:
 111               	.LBE15:
  84:main.c        **** 
  85:main.c        **** 	_delay_ms(1000);
  86:main.c        **** 
  87:main.c        **** 	init_uart();			// init uart
 112               		.loc 1 87 0
 113 0028 00D0      		rcall init_uart
 114               	.LVL3:
  88:main.c        **** 
  89:main.c        **** 	lcd_init();
 115               		.loc 1 89 0
 116 002a 00D0      		rcall lcd_init
 117               	.LVL4:
  90:main.c        **** 	lcd_clrscr();
 118               		.loc 1 90 0
 119 002c 00D0      		rcall lcd_clrscr
 120               	.LVL5:
  91:main.c        **** 
  92:main.c        **** 	sei();
 121               		.loc 1 92 0
 122               	/* #APP */
 123               	 ;  92 "main.c" 1
 124 002e 7894      		sei
 125               	 ;  0 "" 2
  93:main.c        **** 	send("Hello world");
 126               		.loc 1 93 0
 127               	/* #NOAPP */
 128 0030 80E0      		ldi r24,lo8(.LC0)
 129 0032 90E0      		ldi r25,hi8(.LC0)
 130 0034 00D0      		rcall send
 131               	.LVL6:
  94:main.c        **** 
  95:main.c        **** 	DDRB |= 1 << 0;
 132               		.loc 1 95 0
 133 0036 209A      		sbi 0x4,0
 134               	.LBB17:
 135               	.LBB18:
  59:main.c        **** 		lcd_putsf("t1:%d,%d t2:%d,%d", temp[0] / 10, temp[0] % 10, temp[1] / 10, temp[1] % 10);
 136               		.loc 1 59 0
 137 0038 0AE0      		ldi r16,lo8(10)
 138 003a 10E0      		ldi r17,0
  61:main.c        **** 		lcd_putsf("t3:%d,%d", temp[2] / 10, temp[2] % 10);
 139               		.loc 1 61 0
 140 003c 50E0      		ldi r21,lo8(.LC8)
 141 003e 252E      		mov r2,r21
 142 0040 50E0      		ldi r21,hi8(.LC8)
 143 0042 352E      		mov r3,r21
 144               	.LBB19:
  30:main.c        **** 			esp_debugf("Found: "IDSTR", dnum: %u", ID2STR(sensor_id[nfound]), dnum);
 145               		.loc 1 30 0
 146 0044 60E0      		ldi r22,lo8(.LC1)
 147 0046 462E      		mov r4,r22
 148 0048 60E0      		ldi r22,hi8(.LC1)
 149 004a 562E      		mov r5,r22
 150               	.LBE19:
 151               	.LBE18:
 152               	.LBE17:
 153               	.LBB24:
 154               	.LBB25:
  96:main.c        **** 	while (1) {
  97:main.c        **** 		PORTB ^= 1 << 0;
  98:main.c        **** 
  99:main.c        **** 		update_temp();
 100:main.c        **** 
 101:main.c        **** 		if (esp_isMsgToExe()) {
 102:main.c        **** 			char msg_buffer[ESP_RECEIVE_BUFFER_SIZE + 1];
 103:main.c        **** 			esp_getMsg_done(msg_buffer);
 104:main.c        **** 
 105:main.c        **** 			if (strcmp(msg_buffer, CMD_HELLO_AVR) == 0) {
 106:main.c        **** 
 107:main.c        **** 				send(RESPONSE_HELLO_AVR);
 108:main.c        **** 
 109:main.c        **** 			} else if (strcmp(msg_buffer, CMD_GET_SENSORS_ID) == 0) {
 110:main.c        **** 				if (nfound == 0) {
 111:main.c        **** 					esp_sendf("");
 112:main.c        **** 				} else if (nfound == 1) {
 113:main.c        **** 					esp_sendf(IDSTR, ID2STR(sensor_id[0]));
 114:main.c        **** 				} else if (nfound == 2) {
 115:main.c        **** 					esp_sendf(IDSTR", "IDSTR, ID2STR(sensor_id[0]), ID2STR(sensor_id[1]));
 116:main.c        **** 				} else if (nfound == 3) {
 117:main.c        **** 					esp_sendf(IDSTR", "IDSTR", "IDSTR, ID2STR(sensor_id[0]), ID2STR(sensor_id[1]), ID2STR(sensor_i
 118:main.c        **** 				}
 119:main.c        **** 
 120:main.c        **** 			} else if (cmp_cmd_of_msg(msg_buffer, CMD_GET_TEMP) == 0) {
 121:main.c        **** 				/* 23 = strlen(28:ff:da:60:62:14:03:e4) */
 122:main.c        **** 
 123:main.c        **** 				char b[IDSTR_LEN + 1];
 124:main.c        **** 				uint8_t i = 0;
 125:main.c        **** 				uint8_t j = 0;
 126:main.c        **** 				uint8_t k = 0;
 127:main.c        **** 
 128:main.c        **** 				for (i = 0; i < nfound && k != IDSTR_LEN; i++) {
 129:main.c        **** 
 130:main.c        **** 					sprintf(b, IDSTR, ID2STR(sensor_id[i]));
 155               		.loc 1 130 0
 156 004c 6E01      		movw r12,r28
 157 004e 56E6      		ldi r21,102
 158 0050 C50E      		add r12,r21
 159 0052 D11C      		adc r13,__zero_reg__
 160               	.L32:
 161               	.LBE25:
 162               	.LBE24:
 163               	.LBB28:
 164               	.LBB22:
  55:main.c        **** 		lcd_putsf("t1:%d,%d", temp[0] / 10, temp[0] % 10);
 165               		.loc 1 55 0
 166 0054 20E0      		ldi r18,lo8(.LC5)
 167 0056 E22E      		mov r14,r18
 168 0058 20E0      		ldi r18,hi8(.LC5)
 169 005a F22E      		mov r15,r18
  57:main.c        **** 		lcd_putsf("t2:%d,%d", temp[1] / 10, temp[1] % 10);
 170               		.loc 1 57 0
 171 005c 30E0      		ldi r19,lo8(.LC6)
 172 005e 632E      		mov r6,r19
 173 0060 30E0      		ldi r19,hi8(.LC6)
 174 0062 732E      		mov r7,r19
 175               	.LBB20:
  37:main.c        **** 			lcd_putsf("No sensor found");
 176               		.loc 1 37 0
 177 0064 40E0      		ldi r20,lo8(.LC3)
 178 0066 842E      		mov r8,r20
 179 0068 40E0      		ldi r20,hi8(.LC3)
 180 006a 942E      		mov r9,r20
 181               	.L15:
 182               	.LBE20:
 183               	.LBE22:
 184               	.LBE28:
  97:main.c        **** 		PORTB ^= 1 << 0;
 185               		.loc 1 97 0
 186 006c 85B1      		in r24,0x5
 187 006e 91E0      		ldi r25,lo8(1)
 188 0070 8927      		eor r24,r25
 189 0072 85B9      		out 0x5,r24
 190               	.LBB29:
 191               	.LBB23:
  22:main.c        **** 	if (!nfound) {
 192               		.loc 1 22 0
 193 0074 8091 0000 		lds r24,nfound
 194 0078 8111      		cpse r24,__zero_reg__
 195 007a 00C0      		rjmp .L3
 196               	.LVL7:
 197               	.LBB21:
  25:main.c        **** 		ow_reset();
 198               		.loc 1 25 0
 199 007c 00D0      		rcall ow_reset
 200               	.LVL8:
  23:main.c        **** 		uint8_t dnum = OW_SEARCH_FIRST;
 201               		.loc 1 23 0
 202 007e 8FEF      		ldi r24,lo8(-1)
 203               	.LVL9:
 204               	.L6:
  28:main.c        **** 			if (nfound) memcpy(sensor_id[nfound], sensor_id[nfound - 1], OW_ROMCODE_SIZE);
 205               		.loc 1 28 0
 206 0080 9091 0000 		lds r25,nfound
 207 0084 692F      		mov r22,r25
 208 0086 70E0      		ldi r23,0
 209 0088 9923      		tst r25
 210 008a 01F0      		breq .L4
 211 008c DB01      		movw r26,r22
 212 008e 53E0      		ldi r21,3
 213               		1:
 214 0090 AA0F      		lsl r26
 215 0092 BB1F      		rol r27
 216 0094 5A95      		dec r21
 217 0096 01F4      		brne 1b
 218 0098 A050      		subi r26,lo8(-(sensor_id))
 219 009a B040      		sbci r27,hi8(-(sensor_id))
 220 009c FB01      		movw r30,r22
 221 009e 93E0      		ldi r25,3
 222               		1:
 223 00a0 EE0F      		lsl r30
 224 00a2 FF1F      		rol r31
 225 00a4 9A95      		dec r25
 226 00a6 01F4      		brne 1b
 227 00a8 E050      		subi r30,lo8(-(sensor_id-8))
 228 00aa F040      		sbci r31,hi8(-(sensor_id-8))
 229 00ac 98E0      		ldi r25,lo8(8)
 230               		0:
 231 00ae 0190      		ld r0,Z+
 232 00b0 0D92      		st X+,r0
 233 00b2 9A95      		dec r25
 234 00b4 01F4      		brne 0b
 235               	.L4:
  29:main.c        **** 			dnum = ow_rom_search(dnum, sensor_id[nfound]);
 236               		.loc 1 29 0
 237 00b6 43E0      		ldi r20,3
 238               		1:
 239 00b8 660F      		lsl r22
 240 00ba 771F      		rol r23
 241 00bc 4A95      		dec r20
 242 00be 01F4      		brne 1b
 243 00c0 6050      		subi r22,lo8(-(sensor_id))
 244 00c2 7040      		sbci r23,hi8(-(sensor_id))
 245 00c4 00D0      		rcall ow_rom_search
 246               	.LVL10:
  30:main.c        **** 			esp_debugf("Found: "IDSTR", dnum: %u", ID2STR(sensor_id[nfound]), dnum);
 247               		.loc 1 30 0
 248 00c6 E091 0000 		lds r30,nfound
 249 00ca 1F92      		push __zero_reg__
 250 00cc 8F93      		push r24
 251 00ce A8E0      		ldi r26,lo8(8)
 252 00d0 EA9F      		mul r30,r26
 253 00d2 F001      		movw r30,r0
 254 00d4 1124      		clr __zero_reg__
 255 00d6 E050      		subi r30,lo8(-(sensor_id))
 256 00d8 F040      		sbci r31,hi8(-(sensor_id))
 257 00da 9781      		ldd r25,Z+7
 258 00dc 1F92      		push __zero_reg__
 259 00de 9F93      		push r25
 260 00e0 9681      		ldd r25,Z+6
 261 00e2 1F92      		push __zero_reg__
 262 00e4 9F93      		push r25
 263 00e6 9581      		ldd r25,Z+5
 264 00e8 1F92      		push __zero_reg__
 265 00ea 9F93      		push r25
 266 00ec 9481      		ldd r25,Z+4
 267 00ee 1F92      		push __zero_reg__
 268 00f0 9F93      		push r25
 269 00f2 9381      		ldd r25,Z+3
 270 00f4 1F92      		push __zero_reg__
 271 00f6 9F93      		push r25
 272 00f8 9281      		ldd r25,Z+2
 273 00fa 1F92      		push __zero_reg__
 274 00fc 9F93      		push r25
 275 00fe 9181      		ldd r25,Z+1
 276 0100 1F92      		push __zero_reg__
 277 0102 9F93      		push r25
 278 0104 9081      		ld r25,Z
 279 0106 1F92      		push __zero_reg__
 280 0108 9F93      		push r25
 281 010a 5F92      		push r5
 282 010c 4F92      		push r4
 283 010e EF96      		adiw r28,126-63
 284 0110 8FAF      		std Y+63,r24
 285 0112 EF97      		sbiw r28,126-63
 286 0114 00D0      		rcall esp_debugf
 287               	.LVL11:
  31:main.c        **** 			nfound++;
 288               		.loc 1 31 0
 289 0116 9091 0000 		lds r25,nfound
 290 011a 9F5F      		subi r25,lo8(-(1))
 291 011c 9093 0000 		sts nfound,r25
 292               	.LVL12:
  27:main.c        **** 		while (dnum != OW_LAST_DEVICE) {
 293               		.loc 1 27 0
 294 0120 0FB6      		in __tmp_reg__,__SREG__
 295 0122 F894      		cli
 296 0124 DEBF      		out __SP_H__,r29
 297 0126 0FBE      		out __SREG__,__tmp_reg__
 298 0128 CDBF      		out __SP_L__,r28
 299 012a EF96      		adiw r28,126-63
 300 012c 8FAD      		ldd r24,Y+63
 301 012e EF97      		sbiw r28,126-63
 302 0130 8111      		cpse r24,__zero_reg__
 303 0132 00C0      		rjmp .L6
  34:main.c        **** 		if (!nfound) {
 304               		.loc 1 34 0
 305 0134 9111      		cpse r25,__zero_reg__
 306 0136 00C0      		rjmp .L7
  35:main.c        **** 			esp_debug("Error: No sensor founds!");
 307               		.loc 1 35 0
 308 0138 80E0      		ldi r24,lo8(.LC2)
 309 013a 90E0      		ldi r25,hi8(.LC2)
 310 013c 00D0      		rcall esp_debug
 311               	.LVL13:
  36:main.c        **** 			lcd_clrscr();
 312               		.loc 1 36 0
 313 013e 00D0      		rcall lcd_clrscr
 314               	.LVL14:
  37:main.c        **** 			lcd_putsf("No sensor found");
 315               		.loc 1 37 0
 316 0140 9F92      		push r9
 317 0142 8F92      		push r8
 318 0144 00D0      		rcall lcd_putsf
 319               	.LVL15:
 320 0146 0F90      		pop __tmp_reg__
 321 0148 0F90      		pop __tmp_reg__
 322 014a 00C0      		rjmp .L8
 323               	.LVL16:
 324               	.L7:
  41:main.c        **** 		esp_debugf("Found: %u", nfound);
 325               		.loc 1 41 0
 326 014c 1F92      		push __zero_reg__
 327 014e 9F93      		push r25
 328 0150 A0E0      		ldi r26,lo8(.LC4)
 329 0152 B0E0      		ldi r27,hi8(.LC4)
 330 0154 BF93      		push r27
 331 0156 AF93      		push r26
 332 0158 00D0      		rcall esp_debugf
 333               	.LVL17:
 334 015a 0F90      		pop __tmp_reg__
 335 015c 0F90      		pop __tmp_reg__
 336 015e 0F90      		pop __tmp_reg__
 337 0160 0F90      		pop __tmp_reg__
 338               	.L3:
  23:main.c        **** 		uint8_t dnum = OW_SEARCH_FIRST;
 339               		.loc 1 23 0
 340 0162 B12C      		mov r11,__zero_reg__
 341               	.L9:
 342               	.LVL18:
 343               	.LBE21:
  45:main.c        **** 	for (i = 0; i < nfound; i++) {
 344               		.loc 1 45 0
 345 0164 8091 0000 		lds r24,nfound
 346 0168 B816      		cp r11,r24
 347 016a 00F4      		brsh .L45
  46:main.c        **** 		if (DS18X20_conversion_in_progress()) return;
 348               		.loc 1 46 0
 349 016c 00D0      		rcall DS18X20_conversion_in_progress
 350               	.LVL19:
 351 016e 8111      		cpse r24,__zero_reg__
 352 0170 00C0      		rjmp .L8
  47:main.c        **** 		DS18X20_read_decicelsius(&sensor_id[i][0], &temp[i]);
 353               		.loc 1 47 0
 354 0172 8B2D      		mov r24,r11
 355 0174 90E0      		ldi r25,0
 356 0176 BC01      		movw r22,r24
 357 0178 660F      		lsl r22
 358 017a 771F      		rol r23
 359 017c 6050      		subi r22,lo8(-(temp))
 360 017e 7040      		sbci r23,hi8(-(temp))
 361 0180 33E0      		ldi r19,3
 362               		1:
 363 0182 880F      		lsl r24
 364 0184 991F      		rol r25
 365 0186 3A95      		dec r19
 366 0188 01F4      		brne 1b
 367 018a 8050      		subi r24,lo8(-(sensor_id))
 368 018c 9040      		sbci r25,hi8(-(sensor_id))
 369 018e 00D0      		rcall DS18X20_read_decicelsius
 370               	.LVL20:
  45:main.c        **** 	for (i = 0; i < nfound; i++) {
 371               		.loc 1 45 0
 372 0190 B394      		inc r11
 373               	.LVL21:
 374 0192 00C0      		rjmp .L9
 375               	.L45:
  50:main.c        **** 	lcd_clrscr();
 376               		.loc 1 50 0
 377 0194 00D0      		rcall lcd_clrscr
 378               	.LVL22:
  52:main.c        **** 	if (nfound == 1) {
 379               		.loc 1 52 0
 380 0196 8091 0000 		lds r24,nfound
 381 019a 8130      		cpi r24,lo8(1)
 382 019c 01F4      		brne .L11
  53:main.c        **** 		lcd_putsf("t1:%d,%d", temp[0] / 10, temp[0] % 10);
 383               		.loc 1 53 0
 384 019e 8091 0000 		lds r24,temp
 385 01a2 9091 0000 		lds r25,temp+1
 386 01a6 B801      		movw r22,r16
 387 01a8 00D0      		rcall __divmodhi4
 388 01aa 9F93      		push r25
 389 01ac 8F93      		push r24
 390 01ae 7F93      		push r23
 391 01b0 6F93      		push r22
 392 01b2 FF92      		push r15
 393 01b4 EF92      		push r14
 394 01b6 00D0      		rcall lcd_putsf
 395               	.LVL23:
 396 01b8 0F90      		pop __tmp_reg__
 397 01ba 0F90      		pop __tmp_reg__
 398 01bc 0F90      		pop __tmp_reg__
 399 01be 0F90      		pop __tmp_reg__
 400 01c0 0F90      		pop __tmp_reg__
 401 01c2 0F90      		pop __tmp_reg__
 402 01c4 00C0      		rjmp .L12
 403               	.L11:
  54:main.c        **** 	} else if (nfound == 2) {
 404               		.loc 1 54 0
 405 01c6 8230      		cpi r24,lo8(2)
 406 01c8 01F4      		brne .L13
  55:main.c        **** 		lcd_putsf("t1:%d,%d", temp[0] / 10, temp[0] % 10);
 407               		.loc 1 55 0
 408 01ca 8091 0000 		lds r24,temp
 409 01ce 9091 0000 		lds r25,temp+1
 410 01d2 B801      		movw r22,r16
 411 01d4 00D0      		rcall __divmodhi4
 412 01d6 9F93      		push r25
 413 01d8 8F93      		push r24
 414 01da 7F93      		push r23
 415 01dc 6F93      		push r22
 416 01de FF92      		push r15
 417 01e0 EF92      		push r14
 418 01e2 00D0      		rcall lcd_putsf
 419               	.LVL24:
  56:main.c        **** 		lcd_goto(0x40);
 420               		.loc 1 56 0
 421 01e4 80E4      		ldi r24,lo8(64)
 422 01e6 00D0      		rcall lcd_goto
 423               	.LVL25:
  57:main.c        **** 		lcd_putsf("t2:%d,%d", temp[1] / 10, temp[1] % 10);
 424               		.loc 1 57 0
 425 01e8 8091 0000 		lds r24,temp+2
 426 01ec 9091 0000 		lds r25,temp+2+1
 427 01f0 B801      		movw r22,r16
 428 01f2 00D0      		rcall __divmodhi4
 429 01f4 9F93      		push r25
 430 01f6 8F93      		push r24
 431 01f8 7F93      		push r23
 432 01fa 6F93      		push r22
 433 01fc 7F92      		push r7
 434 01fe 6F92      		push r6
 435 0200 00C0      		rjmp .L43
 436               	.L13:
  58:main.c        **** 	} else if (nfound == 3) {
 437               		.loc 1 58 0
 438 0202 8330      		cpi r24,lo8(3)
 439 0204 01F4      		brne .L12
  59:main.c        **** 		lcd_putsf("t1:%d,%d t2:%d,%d", temp[0] / 10, temp[0] % 10, temp[1] / 10, temp[1] % 10);
 440               		.loc 1 59 0
 441 0206 8091 0000 		lds r24,temp+2
 442 020a 9091 0000 		lds r25,temp+2+1
 443 020e 2091 0000 		lds r18,temp
 444 0212 3091 0000 		lds r19,temp+1
 445 0216 B801      		movw r22,r16
 446 0218 00D0      		rcall __divmodhi4
 447 021a 9F93      		push r25
 448 021c 8F93      		push r24
 449 021e 7F93      		push r23
 450 0220 6F93      		push r22
 451 0222 C901      		movw r24,r18
 452 0224 B801      		movw r22,r16
 453 0226 00D0      		rcall __divmodhi4
 454 0228 9F93      		push r25
 455 022a 8F93      		push r24
 456 022c 7F93      		push r23
 457 022e 6F93      		push r22
 458 0230 A0E0      		ldi r26,lo8(.LC7)
 459 0232 B0E0      		ldi r27,hi8(.LC7)
 460 0234 BF93      		push r27
 461 0236 AF93      		push r26
 462 0238 00D0      		rcall lcd_putsf
 463               	.LVL26:
  60:main.c        **** 		lcd_goto(0x40);
 464               		.loc 1 60 0
 465 023a 80E4      		ldi r24,lo8(64)
 466 023c 00D0      		rcall lcd_goto
 467               	.LVL27:
  61:main.c        **** 		lcd_putsf("t3:%d,%d", temp[2] / 10, temp[2] % 10);
 468               		.loc 1 61 0
 469 023e 8091 0000 		lds r24,temp+4
 470 0242 9091 0000 		lds r25,temp+4+1
 471 0246 B801      		movw r22,r16
 472 0248 00D0      		rcall __divmodhi4
 473 024a 9F93      		push r25
 474 024c 8F93      		push r24
 475 024e 7F93      		push r23
 476 0250 6F93      		push r22
 477 0252 3F92      		push r3
 478 0254 2F92      		push r2
 479               	.L43:
 480 0256 00D0      		rcall lcd_putsf
 481               	.LVL28:
 482 0258 0FB6      		in __tmp_reg__,__SREG__
 483 025a F894      		cli
 484 025c DEBF      		out __SP_H__,r29
 485 025e 0FBE      		out __SREG__,__tmp_reg__
 486 0260 CDBF      		out __SP_L__,r28
 487               	.L12:
  64:main.c        **** 	DS18X20_start_meas( DS18X20_POWER_EXTERN, NULL);
 488               		.loc 1 64 0
 489 0262 60E0      		ldi r22,0
 490 0264 70E0      		ldi r23,0
 491 0266 81E0      		ldi r24,lo8(1)
 492 0268 00D0      		rcall DS18X20_start_meas
 493               	.LVL29:
 494               	.L8:
 495               	.LBE23:
 496               	.LBE29:
 101:main.c        **** 		if (esp_isMsgToExe()) {
 497               		.loc 1 101 0
 498 026a 00D0      		rcall esp_isMsgToExe
 499               	.LVL30:
 500 026c 8823      		tst r24
 501 026e 01F4      		brne .+2
 502 0270 00C0      		rjmp .L15
 503               	.LBB30:
 103:main.c        **** 			esp_getMsg_done(msg_buffer);
 504               		.loc 1 103 0
 505 0272 CE01      		movw r24,r28
 506 0274 0196      		adiw r24,1
 507 0276 00D0      		rcall esp_getMsg_done
 508               	.LVL31:
 105:main.c        **** 			if (strcmp(msg_buffer, CMD_HELLO_AVR) == 0) {
 509               		.loc 1 105 0
 510 0278 60E0      		ldi r22,lo8(.LC9)
 511 027a 70E0      		ldi r23,hi8(.LC9)
 512 027c CE01      		movw r24,r28
 513 027e 0196      		adiw r24,1
 514 0280 00D0      		rcall strcmp
 515               	.LVL32:
 516 0282 892B      		or r24,r25
 517 0284 01F4      		brne .L16
 107:main.c        **** 				send(RESPONSE_HELLO_AVR);
 518               		.loc 1 107 0
 519 0286 80E0      		ldi r24,lo8(.LC9)
 520 0288 90E0      		ldi r25,hi8(.LC9)
 521 028a 00D0      		rcall send
 522               	.LVL33:
 523 028c 00C0      		rjmp .L32
 524               	.L16:
 109:main.c        **** 			} else if (strcmp(msg_buffer, CMD_GET_SENSORS_ID) == 0) {
 525               		.loc 1 109 0
 526 028e 60E0      		ldi r22,lo8(.LC10)
 527 0290 70E0      		ldi r23,hi8(.LC10)
 528 0292 CE01      		movw r24,r28
 529 0294 0196      		adiw r24,1
 530 0296 00D0      		rcall strcmp
 531               	.LVL34:
 532 0298 892B      		or r24,r25
 533 029a 01F0      		breq .L18
 534 029c 40E0      		ldi r20,0
 535 029e B12C      		mov r11,__zero_reg__
 536               	.LBB26:
 537               		.loc 1 130 0
 538 02a0 90E0      		ldi r25,lo8(.LC12)
 539 02a2 E92E      		mov r14,r25
 540 02a4 90E0      		ldi r25,hi8(.LC12)
 541 02a6 F92E      		mov r15,r25
 542 02a8 00C0      		rjmp .L19
 543               	.L18:
 544               	.LBE26:
 110:main.c        **** 				if (nfound == 0) {
 545               		.loc 1 110 0
 546 02aa 8091 0000 		lds r24,nfound
 547 02ae 8111      		cpse r24,__zero_reg__
 548 02b0 00C0      		rjmp .L20
 111:main.c        **** 					esp_sendf("");
 549               		.loc 1 111 0
 550 02b2 80E0      		ldi r24,lo8(.LC11)
 551 02b4 90E0      		ldi r25,hi8(.LC11)
 552 02b6 00C0      		rjmp .L40
 553               	.L20:
 112:main.c        **** 				} else if (nfound == 1) {
 554               		.loc 1 112 0
 555 02b8 8130      		cpi r24,lo8(1)
 556 02ba 01F4      		brne .L21
 113:main.c        **** 					esp_sendf(IDSTR, ID2STR(sensor_id[0]));
 557               		.loc 1 113 0
 558 02bc 8091 0000 		lds r24,sensor_id+7
 559 02c0 1F92      		push __zero_reg__
 560 02c2 8F93      		push r24
 561 02c4 8091 0000 		lds r24,sensor_id+6
 562 02c8 1F92      		push __zero_reg__
 563 02ca 8F93      		push r24
 564 02cc 8091 0000 		lds r24,sensor_id+5
 565 02d0 1F92      		push __zero_reg__
 566 02d2 8F93      		push r24
 567 02d4 8091 0000 		lds r24,sensor_id+4
 568 02d8 1F92      		push __zero_reg__
 569 02da 8F93      		push r24
 570 02dc 8091 0000 		lds r24,sensor_id+3
 571 02e0 1F92      		push __zero_reg__
 572 02e2 8F93      		push r24
 573 02e4 8091 0000 		lds r24,sensor_id+2
 574 02e8 1F92      		push __zero_reg__
 575 02ea 8F93      		push r24
 576 02ec 8091 0000 		lds r24,sensor_id+1
 577 02f0 1F92      		push __zero_reg__
 578 02f2 8F93      		push r24
 579 02f4 8091 0000 		lds r24,sensor_id
 580 02f8 1F92      		push __zero_reg__
 581 02fa 8F93      		push r24
 582 02fc 80E0      		ldi r24,lo8(.LC12)
 583 02fe 90E0      		ldi r25,hi8(.LC12)
 584 0300 9F93      		push r25
 585 0302 8F93      		push r24
 586 0304 00D0      		rcall esp_sendf
 587               	.LVL35:
 588 0306 00C0      		rjmp .L41
 589               	.L21:
 114:main.c        **** 				} else if (nfound == 2) {
 590               		.loc 1 114 0
 591 0308 8230      		cpi r24,lo8(2)
 592 030a 01F0      		breq .+2
 593 030c 00C0      		rjmp .L22
 115:main.c        **** 					esp_sendf(IDSTR", "IDSTR, ID2STR(sensor_id[0]), ID2STR(sensor_id[1]));
 594               		.loc 1 115 0
 595 030e 8091 0000 		lds r24,sensor_id+15
 596 0312 1F92      		push __zero_reg__
 597 0314 8F93      		push r24
 598 0316 8091 0000 		lds r24,sensor_id+14
 599 031a 1F92      		push __zero_reg__
 600 031c 8F93      		push r24
 601 031e 8091 0000 		lds r24,sensor_id+13
 602 0322 1F92      		push __zero_reg__
 603 0324 8F93      		push r24
 604 0326 8091 0000 		lds r24,sensor_id+12
 605 032a 1F92      		push __zero_reg__
 606 032c 8F93      		push r24
 607 032e 8091 0000 		lds r24,sensor_id+11
 608 0332 1F92      		push __zero_reg__
 609 0334 8F93      		push r24
 610 0336 8091 0000 		lds r24,sensor_id+10
 611 033a 1F92      		push __zero_reg__
 612 033c 8F93      		push r24
 613 033e 8091 0000 		lds r24,sensor_id+9
 614 0342 1F92      		push __zero_reg__
 615 0344 8F93      		push r24
 616 0346 8091 0000 		lds r24,sensor_id+8
 617 034a 1F92      		push __zero_reg__
 618 034c 8F93      		push r24
 619 034e 8091 0000 		lds r24,sensor_id+7
 620 0352 1F92      		push __zero_reg__
 621 0354 8F93      		push r24
 622 0356 8091 0000 		lds r24,sensor_id+6
 623 035a 1F92      		push __zero_reg__
 624 035c 8F93      		push r24
 625 035e 8091 0000 		lds r24,sensor_id+5
 626 0362 1F92      		push __zero_reg__
 627 0364 8F93      		push r24
 628 0366 8091 0000 		lds r24,sensor_id+4
 629 036a 1F92      		push __zero_reg__
 630 036c 8F93      		push r24
 631 036e 8091 0000 		lds r24,sensor_id+3
 632 0372 1F92      		push __zero_reg__
 633 0374 8F93      		push r24
 634 0376 8091 0000 		lds r24,sensor_id+2
 635 037a 1F92      		push __zero_reg__
 636 037c 8F93      		push r24
 637 037e 8091 0000 		lds r24,sensor_id+1
 638 0382 1F92      		push __zero_reg__
 639 0384 8F93      		push r24
 640 0386 8091 0000 		lds r24,sensor_id
 641 038a 1F92      		push __zero_reg__
 642 038c 8F93      		push r24
 643 038e 80E0      		ldi r24,lo8(.LC13)
 644 0390 90E0      		ldi r25,hi8(.LC13)
 645 0392 9F93      		push r25
 646 0394 8F93      		push r24
 647 0396 00D0      		rcall esp_sendf
 648               	.LVL36:
 649 0398 00C0      		rjmp .L41
 650               	.L22:
 116:main.c        **** 				} else if (nfound == 3) {
 651               		.loc 1 116 0
 652 039a 8330      		cpi r24,lo8(3)
 653 039c 01F0      		breq .+2
 654 039e 00C0      		rjmp .L32
 117:main.c        **** 					esp_sendf(IDSTR", "IDSTR", "IDSTR, ID2STR(sensor_id[0]), ID2STR(sensor_id[1]), ID2STR(sensor_i
 655               		.loc 1 117 0
 656 03a0 8091 0000 		lds r24,sensor_id+23
 657 03a4 1F92      		push __zero_reg__
 658 03a6 8F93      		push r24
 659 03a8 8091 0000 		lds r24,sensor_id+22
 660 03ac 1F92      		push __zero_reg__
 661 03ae 8F93      		push r24
 662 03b0 8091 0000 		lds r24,sensor_id+21
 663 03b4 1F92      		push __zero_reg__
 664 03b6 8F93      		push r24
 665 03b8 8091 0000 		lds r24,sensor_id+20
 666 03bc 1F92      		push __zero_reg__
 667 03be 8F93      		push r24
 668 03c0 8091 0000 		lds r24,sensor_id+19
 669 03c4 1F92      		push __zero_reg__
 670 03c6 8F93      		push r24
 671 03c8 8091 0000 		lds r24,sensor_id+18
 672 03cc 1F92      		push __zero_reg__
 673 03ce 8F93      		push r24
 674 03d0 8091 0000 		lds r24,sensor_id+17
 675 03d4 1F92      		push __zero_reg__
 676 03d6 8F93      		push r24
 677 03d8 8091 0000 		lds r24,sensor_id+16
 678 03dc 1F92      		push __zero_reg__
 679 03de 8F93      		push r24
 680 03e0 8091 0000 		lds r24,sensor_id+15
 681 03e4 1F92      		push __zero_reg__
 682 03e6 8F93      		push r24
 683 03e8 8091 0000 		lds r24,sensor_id+14
 684 03ec 1F92      		push __zero_reg__
 685 03ee 8F93      		push r24
 686 03f0 8091 0000 		lds r24,sensor_id+13
 687 03f4 1F92      		push __zero_reg__
 688 03f6 8F93      		push r24
 689 03f8 8091 0000 		lds r24,sensor_id+12
 690 03fc 1F92      		push __zero_reg__
 691 03fe 8F93      		push r24
 692 0400 8091 0000 		lds r24,sensor_id+11
 693 0404 1F92      		push __zero_reg__
 694 0406 8F93      		push r24
 695 0408 8091 0000 		lds r24,sensor_id+10
 696 040c 1F92      		push __zero_reg__
 697 040e 8F93      		push r24
 698 0410 8091 0000 		lds r24,sensor_id+9
 699 0414 1F92      		push __zero_reg__
 700 0416 8F93      		push r24
 701 0418 8091 0000 		lds r24,sensor_id+8
 702 041c 1F92      		push __zero_reg__
 703 041e 8F93      		push r24
 704 0420 8091 0000 		lds r24,sensor_id+7
 705 0424 1F92      		push __zero_reg__
 706 0426 8F93      		push r24
 707 0428 8091 0000 		lds r24,sensor_id+6
 708 042c 1F92      		push __zero_reg__
 709 042e 8F93      		push r24
 710 0430 8091 0000 		lds r24,sensor_id+5
 711 0434 1F92      		push __zero_reg__
 712 0436 8F93      		push r24
 713 0438 8091 0000 		lds r24,sensor_id+4
 714 043c 1F92      		push __zero_reg__
 715 043e 8F93      		push r24
 716 0440 8091 0000 		lds r24,sensor_id+3
 717 0444 1F92      		push __zero_reg__
 718 0446 8F93      		push r24
 719 0448 8091 0000 		lds r24,sensor_id+2
 720 044c 1F92      		push __zero_reg__
 721 044e 8F93      		push r24
 722 0450 8091 0000 		lds r24,sensor_id+1
 723 0454 1F92      		push __zero_reg__
 724 0456 8F93      		push r24
 725 0458 8091 0000 		lds r24,sensor_id
 726 045c 1F92      		push __zero_reg__
 727 045e 8F93      		push r24
 728 0460 80E0      		ldi r24,lo8(.LC14)
 729 0462 90E0      		ldi r25,hi8(.LC14)
 730 0464 9F93      		push r25
 731 0466 8F93      		push r24
 732 0468 00D0      		rcall esp_sendf
 733               	.LVL37:
 734               	.L41:
 735 046a 0FB6      		in __tmp_reg__,__SREG__
 736 046c F894      		cli
 737 046e DEBF      		out __SP_H__,r29
 738 0470 0FBE      		out __SREG__,__tmp_reg__
 739 0472 CDBF      		out __SP_L__,r28
 740 0474 00C0      		rjmp .L32
 741               	.LVL38:
 742               	.L46:
 743 0476 F601      		movw r30,r12
 744               	.LBB27:
 131:main.c        **** 
 132:main.c        **** 					for (j = 0; msg_buffer[j] != ':'; j++)
 133:main.c        **** 						;
 134:main.c        **** 					j += 1;
 745               		.loc 1 134 0
 746 0478 80E0      		ldi r24,0
 747 047a 90E0      		ldi r25,0
 748 047c A1E0      		ldi r26,lo8(1)
 749 047e B0E0      		ldi r27,0
 750 0480 AC0F      		add r26,r28
 751 0482 BD1F      		adc r27,r29
 752 0484 A20F      		add r26,r18
 753 0486 B11D      		adc r27,__zero_reg__
 754 0488 9D01      		movw r18,r26
 755               	.LVL39:
 756               	.L25:
 757 048a 482F      		mov r20,r24
 758               	.LVL40:
 135:main.c        **** 
 136:main.c        **** 					for (k = 0; k < IDSTR_LEN && msg_buffer[j + k] == b[k]; k++)
 759               		.loc 1 136 0 discriminator 2
 760 048c 5191      		ld r21,Z+
 761 048e D901      		movw r26,r18
 762 0490 A80F      		add r26,r24
 763 0492 B91F      		adc r27,r25
 764 0494 6C91      		ld r22,X
 765 0496 6517      		cp r22,r21
 766 0498 01F4      		brne .+2
 767 049a 00C0      		rjmp .L27
 768               	.LVL41:
 769               	.L26:
 128:main.c        **** 				for (i = 0; i < nfound && k != IDSTR_LEN; i++) {
 770               		.loc 1 128 0
 771 049c B394      		inc r11
 772               	.LVL42:
 773               	.L19:
 128:main.c        **** 				for (i = 0; i < nfound && k != IDSTR_LEN; i++) {
 774               		.loc 1 128 0 is_stmt 0 discriminator 1
 775 049e 8091 0000 		lds r24,nfound
 776 04a2 B816      		cp r11,r24
 777 04a4 00F0      		brlo .+2
 778 04a6 00C0      		rjmp .L28
 128:main.c        **** 				for (i = 0; i < nfound && k != IDSTR_LEN; i++) {
 779               		.loc 1 128 0 discriminator 2
 780 04a8 4731      		cpi r20,lo8(23)
 781 04aa 01F0      		breq .L31
 130:main.c        **** 					sprintf(b, IDSTR, ID2STR(sensor_id[i]));
 782               		.loc 1 130 0 is_stmt 1
 783 04ac 38E0      		ldi r19,lo8(8)
 784 04ae B39E      		mul r11,r19
 785 04b0 F001      		movw r30,r0
 786 04b2 1124      		clr __zero_reg__
 787 04b4 E050      		subi r30,lo8(-(sensor_id))
 788 04b6 F040      		sbci r31,hi8(-(sensor_id))
 789 04b8 8781      		ldd r24,Z+7
 790 04ba 1F92      		push __zero_reg__
 791 04bc 8F93      		push r24
 792 04be 8681      		ldd r24,Z+6
 793 04c0 1F92      		push __zero_reg__
 794 04c2 8F93      		push r24
 795 04c4 8581      		ldd r24,Z+5
 796 04c6 1F92      		push __zero_reg__
 797 04c8 8F93      		push r24
 798 04ca 8481      		ldd r24,Z+4
 799 04cc 1F92      		push __zero_reg__
 800 04ce 8F93      		push r24
 801 04d0 8381      		ldd r24,Z+3
 802 04d2 1F92      		push __zero_reg__
 803 04d4 8F93      		push r24
 804 04d6 8281      		ldd r24,Z+2
 805 04d8 1F92      		push __zero_reg__
 806 04da 8F93      		push r24
 807 04dc 8181      		ldd r24,Z+1
 808 04de 1F92      		push __zero_reg__
 809 04e0 8F93      		push r24
 810 04e2 8081      		ld r24,Z
 811 04e4 1F92      		push __zero_reg__
 812 04e6 8F93      		push r24
 813 04e8 FF92      		push r15
 814 04ea EF92      		push r14
 815 04ec DF92      		push r13
 816 04ee CF92      		push r12
 817 04f0 00D0      		rcall sprintf
 818               	.LVL43:
 132:main.c        **** 					for (j = 0; msg_buffer[j] != ':'; j++)
 819               		.loc 1 132 0
 820 04f2 0FB6      		in __tmp_reg__,__SREG__
 821 04f4 F894      		cli
 822 04f6 DEBF      		out __SP_H__,r29
 823 04f8 0FBE      		out __SREG__,__tmp_reg__
 824 04fa CDBF      		out __SP_L__,r28
 825 04fc 80E0      		ldi r24,0
 826               	.LVL44:
 827               	.L23:
 132:main.c        **** 					for (j = 0; msg_buffer[j] != ':'; j++)
 828               		.loc 1 132 0 is_stmt 0 discriminator 1
 829 04fe E1E0      		ldi r30,lo8(1)
 830 0500 F0E0      		ldi r31,0
 831 0502 EC0F      		add r30,r28
 832 0504 FD1F      		adc r31,r29
 833 0506 E80F      		add r30,r24
 834 0508 F11D      		adc r31,__zero_reg__
 835 050a 9081      		ld r25,Z
 836 050c 21E0      		ldi r18,lo8(1)
 837 050e 280F      		add r18,r24
 838 0510 9A33      		cpi r25,lo8(58)
 839 0512 01F4      		brne .+2
 840 0514 00C0      		rjmp .L46
 132:main.c        **** 					for (j = 0; msg_buffer[j] != ':'; j++)
 841               		.loc 1 132 0 discriminator 2
 842 0516 822F      		mov r24,r18
 843               	.LVL45:
 844 0518 00C0      		rjmp .L23
 845               	.LVL46:
 846               	.L27:
 847 051a 0196      		adiw r24,1
 848               	.LVL47:
 849               		.loc 1 136 0 is_stmt 1 discriminator 1
 850 051c 8731      		cpi r24,23
 851 051e 9105      		cpc r25,__zero_reg__
 852 0520 01F0      		breq .+2
 853 0522 00C0      		rjmp .L25
 854 0524 47E1      		ldi r20,lo8(23)
 855 0526 00C0      		rjmp .L26
 856               	.LVL48:
 857               	.L31:
 137:main.c        **** 						;
 138:main.c        **** 
 139:main.c        **** 				}
 140:main.c        **** 
 141:main.c        **** 				if (k == IDSTR_LEN) esp_sendf("%i", temp[i - 1]);
 858               		.loc 1 141 0
 859 0528 EB2D      		mov r30,r11
 860 052a F0E0      		ldi r31,0
 861 052c EE0F      		lsl r30
 862 052e FF1F      		rol r31
 863 0530 E050      		subi r30,lo8(-(temp-2))
 864 0532 F040      		sbci r31,hi8(-(temp-2))
 865 0534 8181      		ldd r24,Z+1
 866 0536 8F93      		push r24
 867 0538 8081      		ld r24,Z
 868 053a 8F93      		push r24
 869 053c 80E0      		ldi r24,lo8(.LC15)
 870 053e 90E0      		ldi r25,hi8(.LC15)
 871 0540 9F93      		push r25
 872 0542 8F93      		push r24
 873 0544 00D0      		rcall esp_sendf
 874               	.LVL49:
 875 0546 0F90      		pop __tmp_reg__
 876 0548 0F90      		pop __tmp_reg__
 877 054a 0F90      		pop __tmp_reg__
 878 054c 0F90      		pop __tmp_reg__
 879 054e 00C0      		rjmp .L32
 880               	.LVL50:
 881               	.L28:
 882 0550 4731      		cpi r20,lo8(23)
 883 0552 01F0      		breq .L31
 142:main.c        **** 				else esp_sendf("Err: id not found");
 884               		.loc 1 142 0
 885 0554 80E0      		ldi r24,lo8(.LC16)
 886 0556 90E0      		ldi r25,hi8(.LC16)
 887               	.LVL51:
 888               	.L40:
 889 0558 9F93      		push r25
 890 055a 8F93      		push r24
 891 055c 00D0      		rcall esp_sendf
 892               	.LVL52:
 893 055e 0F90      		pop __tmp_reg__
 894 0560 0F90      		pop __tmp_reg__
 895 0562 00C0      		rjmp .L32
 896               	.LBE27:
 897               	.LBE30:
 898               		.cfi_endproc
 899               	.LFE9:
 901               		.local	temp
 902               		.comm	temp,6,1
 903               		.local	nfound
 904               		.comm	nfound,1,1
 905               		.local	sensor_id
 906               		.comm	sensor_id,24,1
 907               		.text
 908               	.Letext0:
 909               		.file 3 "/usr/lib/avr/include/stdint.h"
 910               		.file 4 "ds1820/onewire.h"
 911               		.file 5 "esp/esp.h"
 912               		.file 6 "lcd/hd44780.h"
 913               		.file 7 "ds1820/ds18x20.h"
 914               		.file 8 "/usr/lib/avr/include/stdio.h"
 915               		.file 9 "/usr/lib/avr/include/string.h"
 916               		.file 10 "uart/uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccSgoMJd.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccSgoMJd.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccSgoMJd.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccSgoMJd.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccSgoMJd.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccSgoMJd.s:12     .text:0000000000000000 cmp_cmd_of_msg
     /tmp/ccSgoMJd.s:67     .text.startup:0000000000000000 main
     /tmp/ccSgoMJd.s:902    .bss:0000000000000006 nfound
     /tmp/ccSgoMJd.s:904    .bss:0000000000000007 sensor_id
                             .bss:0000000000000000 temp

UNDEFINED SYMBOLS
init_uart
lcd_init
lcd_clrscr
send
ow_reset
ow_rom_search
esp_debugf
esp_debug
lcd_putsf
DS18X20_conversion_in_progress
DS18X20_read_decicelsius
__divmodhi4
lcd_goto
DS18X20_start_meas
esp_isMsgToExe
esp_getMsg_done
strcmp
esp_sendf
sprintf
__do_copy_data
__do_clear_bss
